"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/unist-util-find-between-all";
exports.ids = ["vendor-chunks/unist-util-find-between-all"];
exports.modules = {

/***/ "(ssr)/./node_modules/unist-util-find-between-all/dist/lib/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/unist-util-find-between-all/dist/lib/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findAllBetween: () => (/* binding */ findAllBetween)\n/* harmony export */ });\n/* harmony import */ var unist_util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-is */ \"(ssr)/./node_modules/unist-util-is/lib/index.js\");\n/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n */\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesnâ€™t work when publishing on npm.\n */\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n/**\n * @typedef {(\n *   Kind extends {children: Array<infer Child>}\n *   ? Child\n *   : never\n * )} Child\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Kind\n *   All node types.\n */\n\n/**\n * Find the nodes in `parent` between two `node`s or two indexes, that\n * pass `test`. Nodes and indexes at both sides are excluded, but there is an\n * option for including both sides\n *\n * @param parent\n *   Parent node.\n * @param indexStart\n *   Child node or index in the start of between\n * @param indexEnd\n *   Child node or index in the end of between\n * @param [test=undefined]\n *   Test for child to look for (optional).\n * @param [options=undefined]\n *   The behaviour for including or excluding both sides (optional).\n * @returns\n *   Children (matching `test`, if given).\n */\nconst findAllBetween = \n// Note: overloads like this are needed to support optional generics.\n/**\n * @type {(\n *   (<Kind extends UnistParent, Check extends Test>(parent: Kind, indexStart: Child<Kind> | number, indexEnd: Child<Kind> | number, test: Check, options?: Behaviour) => Array<Matches<Child<Kind>, Check>>) &\n *   (<Kind extends UnistParent>(parent: Kind, indexStart: Child<Kind> | number, indexEnd: Child<Kind> | number, test?: null | undefined, options?: Behaviour) => Array<Child<Kind>>)\n * )}\n */\n(\n/**\n * @typedef {({behaviour : \"include\" | \"exclude\"})} Behaviour\n * whether nodes and indexes ath both sides included or exculuded.\n * default behaviour is excluded one.\n */\n/**\n * @param {UnistParent} parent\n * @param {UnistNode | number} indexStart\n * @param {UnistNode | number} indexEnd\n * @param {Test} [test]\n * @param {undefined | Behaviour} [options]\n * @returns {Array<UnistNode>}\n */\n/* eslint max-params: [\"error\", 5] */\nfunction (parent, indexStart, indexEnd, test, options) {\n    const is = (0,unist_util_is__WEBPACK_IMPORTED_MODULE_0__.convert)(test);\n    /** @type {Array<UnistNode>} */\n    const results = [];\n    if (!parent || !parent.type || !parent.children) {\n        throw new Error('Expected parent node');\n    }\n    if (typeof indexStart === 'number') {\n        if (indexStart < 0 || indexStart === Number.POSITIVE_INFINITY) {\n            throw new Error('Expected positive finite number as index for start');\n        }\n    }\n    else {\n        indexStart = parent.children.indexOf(indexStart);\n        if (indexStart < 0) {\n            throw new Error('Expected child node or index for start');\n        }\n    }\n    if (typeof indexEnd === 'number') {\n        if (indexEnd < 0 || indexEnd === Number.POSITIVE_INFINITY) {\n            throw new Error('Expected positive finite number as index for end');\n        }\n    }\n    else {\n        indexEnd = parent.children.indexOf(indexEnd);\n        if (indexEnd < 0) {\n            throw new Error('Expected child node or index for end');\n        }\n    }\n    if (options?.behaviour === 'include') {\n        while (indexStart <= indexEnd) {\n            if (is(parent.children[indexStart], indexStart, parent)) {\n                results.push(parent.children[indexStart]);\n            }\n            indexStart++;\n        }\n    }\n    else {\n        while (++indexStart < indexEnd) {\n            if (is(parent.children[indexStart], indexStart, parent)) {\n                results.push(parent.children[indexStart]);\n            }\n        }\n    }\n    return results;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5pc3QtdXRpbC1maW5kLWJldHdlZW4tYWxsL2Rpc3QvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHdCQUF3QjtBQUNyQztBQUNBO0FBQ0EsYUFBYSw4REFBOEQ7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUN3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFLGtDQUFrQyxHQUFHO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsb0JBQW9CO0FBQy9CLFdBQVcsb0JBQW9CO0FBQy9CLFdBQVcsTUFBTTtBQUNqQixXQUFXLHVCQUF1QjtBQUNsQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzREFBTztBQUN0QixlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyIvVXNlcnMva3J6eXN6dG9ma29jb3QvRGVza3RvcC9sYW5kaW5nLXBhZ2Uvbm9kZV9tb2R1bGVzL3VuaXN0LXV0aWwtZmluZC1iZXR3ZWVuLWFsbC9kaXN0L2xpYi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3VuaXN0JykuTm9kZX0gVW5pc3ROb2RlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdCcpLlBhcmVudH0gVW5pc3RQYXJlbnRcbiAqL1xuLyoqXG4gKiBAdHlwZWRlZiB7RXhjbHVkZTxpbXBvcnQoJ3VuaXN0LXV0aWwtaXMnKS5UZXN0LCB1bmRlZmluZWQ+IHwgdW5kZWZpbmVkfSBUZXN0XG4gKiAgIFRlc3QgZnJvbSBgdW5pc3QtdXRpbC1pc2AuXG4gKlxuICogICBOb3RlOiB3ZSBoYXZlIHJlbW92ZSBhbmQgYWRkIGB1bmRlZmluZWRgLCBiZWNhdXNlIG90aGVyd2lzZSB3aGVuIGdlbmVyYXRpbmdcbiAqICAgYXV0b21hdGljIGAuZC50c2AgZmlsZXMsIFRTIHRyaWVzIHRvIGZsYXR0ZW4gcGF0aHMgZnJvbSBhIGxvY2FsIHBlcnNwZWN0aXZlLFxuICogICB3aGljaCBkb2VzbuKAmXQgd29yayB3aGVuIHB1Ymxpc2hpbmcgb24gbnBtLlxuICovXG4vKipcbiAqIEB0eXBlZGVmIHsoXG4gKiAgIEZuIGV4dGVuZHMgKHZhbHVlOiBhbnkpID0+IHZhbHVlIGlzIGluZmVyIFRoaW5nXG4gKiAgID8gVGhpbmdcbiAqICAgOiBGYWxsYmFja1xuICogKX0gUHJlZGljYXRlXG4gKiAgIEdldCB0aGUgdmFsdWUgb2YgYSB0eXBlIGd1YXJkIGBGbmAuXG4gKiBAdGVtcGxhdGUgRm5cbiAqICAgVmFsdWU7IHR5cGljYWxseSBmdW5jdGlvbiB0aGF0IGlzIGEgdHlwZSBndWFyZCAoc3VjaCBhcyBgKHgpOiB4IGlzIFlgKS5cbiAqIEB0ZW1wbGF0ZSBGYWxsYmFja1xuICogICBWYWx1ZSB0byB5aWVsZCBpZiBgRm5gIGlzIG5vdCBhIHR5cGUgZ3VhcmQuXG4gKi9cbi8qKlxuICogQHR5cGVkZWYgeyhcbiAqICAgQ2hlY2sgZXh0ZW5kcyBudWxsIHwgdW5kZWZpbmVkIC8vIE5vIHRlc3QuXG4gKiAgID8gVmFsdWVcbiAqICAgOiBWYWx1ZSBleHRlbmRzIHt0eXBlOiBDaGVja30gLy8gU3RyaW5nICh0eXBlKSB0ZXN0LlxuICogICA/IFZhbHVlXG4gKiAgIDogVmFsdWUgZXh0ZW5kcyBDaGVjayAvLyBQYXJ0aWFsIHRlc3QuXG4gKiAgID8gVmFsdWVcbiAqICAgOiBDaGVjayBleHRlbmRzIEZ1bmN0aW9uIC8vIEZ1bmN0aW9uIHRlc3QuXG4gKiAgID8gUHJlZGljYXRlPENoZWNrLCBWYWx1ZT4gZXh0ZW5kcyBWYWx1ZVxuICogICAgID8gUHJlZGljYXRlPENoZWNrLCBWYWx1ZT5cbiAqICAgICA6IG5ldmVyXG4gKiAgIDogbmV2ZXIgLy8gU29tZSBvdGhlciB0ZXN0P1xuICogKX0gTWF0Y2hlc09uZVxuICogICBDaGVjayB3aGV0aGVyIGEgbm9kZSBtYXRjaGVzIGEgcHJpbWl0aXZlIGNoZWNrIGluIHRoZSB0eXBlIHN5c3RlbS5cbiAqIEB0ZW1wbGF0ZSBWYWx1ZVxuICogICBWYWx1ZTsgdHlwaWNhbGx5IHVuaXN0IGBOb2RlYC5cbiAqIEB0ZW1wbGF0ZSBDaGVja1xuICogICBWYWx1ZTsgdHlwaWNhbGx5IGB1bmlzdC11dGlsLWlzYC1jb21wYXRpYmxlIHRlc3QsIGJ1dCBub3QgYXJyYXlzLlxuICovXG4vKipcbiAqIEB0eXBlZGVmIHsoXG4gKiAgIENoZWNrIGV4dGVuZHMgQXJyYXk8YW55PlxuICogICA/IE1hdGNoZXNPbmU8VmFsdWUsIENoZWNrW2tleW9mIENoZWNrXT5cbiAqICAgOiBNYXRjaGVzT25lPFZhbHVlLCBDaGVjaz5cbiAqICl9IE1hdGNoZXNcbiAqICAgQ2hlY2sgd2hldGhlciBhIG5vZGUgbWF0Y2hlcyBhIGNoZWNrIGluIHRoZSB0eXBlIHN5c3RlbS5cbiAqIEB0ZW1wbGF0ZSBWYWx1ZVxuICogICBWYWx1ZTsgdHlwaWNhbGx5IHVuaXN0IGBOb2RlYC5cbiAqIEB0ZW1wbGF0ZSBDaGVja1xuICogICBWYWx1ZTsgdHlwaWNhbGx5IGB1bmlzdC11dGlsLWlzYC1jb21wYXRpYmxlIHRlc3QuXG4gKi9cbi8qKlxuICogQHR5cGVkZWYgeyhcbiAqICAgS2luZCBleHRlbmRzIHtjaGlsZHJlbjogQXJyYXk8aW5mZXIgQ2hpbGQ+fVxuICogICA/IENoaWxkXG4gKiAgIDogbmV2ZXJcbiAqICl9IENoaWxkXG4gKiAgIENvbGxlY3Qgbm9kZXMgdGhhdCBjYW4gYmUgcGFyZW50cyBvZiBgQ2hpbGRgLlxuICogQHRlbXBsYXRlIHtVbmlzdE5vZGV9IEtpbmRcbiAqICAgQWxsIG5vZGUgdHlwZXMuXG4gKi9cbmltcG9ydCB7IGNvbnZlcnQgfSBmcm9tICd1bmlzdC11dGlsLWlzJztcbi8qKlxuICogRmluZCB0aGUgbm9kZXMgaW4gYHBhcmVudGAgYmV0d2VlbiB0d28gYG5vZGVgcyBvciB0d28gaW5kZXhlcywgdGhhdFxuICogcGFzcyBgdGVzdGAuIE5vZGVzIGFuZCBpbmRleGVzIGF0IGJvdGggc2lkZXMgYXJlIGV4Y2x1ZGVkLCBidXQgdGhlcmUgaXMgYW5cbiAqIG9wdGlvbiBmb3IgaW5jbHVkaW5nIGJvdGggc2lkZXNcbiAqXG4gKiBAcGFyYW0gcGFyZW50XG4gKiAgIFBhcmVudCBub2RlLlxuICogQHBhcmFtIGluZGV4U3RhcnRcbiAqICAgQ2hpbGQgbm9kZSBvciBpbmRleCBpbiB0aGUgc3RhcnQgb2YgYmV0d2VlblxuICogQHBhcmFtIGluZGV4RW5kXG4gKiAgIENoaWxkIG5vZGUgb3IgaW5kZXggaW4gdGhlIGVuZCBvZiBiZXR3ZWVuXG4gKiBAcGFyYW0gW3Rlc3Q9dW5kZWZpbmVkXVxuICogICBUZXN0IGZvciBjaGlsZCB0byBsb29rIGZvciAob3B0aW9uYWwpLlxuICogQHBhcmFtIFtvcHRpb25zPXVuZGVmaW5lZF1cbiAqICAgVGhlIGJlaGF2aW91ciBmb3IgaW5jbHVkaW5nIG9yIGV4Y2x1ZGluZyBib3RoIHNpZGVzIChvcHRpb25hbCkuXG4gKiBAcmV0dXJuc1xuICogICBDaGlsZHJlbiAobWF0Y2hpbmcgYHRlc3RgLCBpZiBnaXZlbikuXG4gKi9cbmV4cG9ydCBjb25zdCBmaW5kQWxsQmV0d2VlbiA9IFxuLy8gTm90ZTogb3ZlcmxvYWRzIGxpa2UgdGhpcyBhcmUgbmVlZGVkIHRvIHN1cHBvcnQgb3B0aW9uYWwgZ2VuZXJpY3MuXG4vKipcbiAqIEB0eXBlIHsoXG4gKiAgICg8S2luZCBleHRlbmRzIFVuaXN0UGFyZW50LCBDaGVjayBleHRlbmRzIFRlc3Q+KHBhcmVudDogS2luZCwgaW5kZXhTdGFydDogQ2hpbGQ8S2luZD4gfCBudW1iZXIsIGluZGV4RW5kOiBDaGlsZDxLaW5kPiB8IG51bWJlciwgdGVzdDogQ2hlY2ssIG9wdGlvbnM/OiBCZWhhdmlvdXIpID0+IEFycmF5PE1hdGNoZXM8Q2hpbGQ8S2luZD4sIENoZWNrPj4pICZcbiAqICAgKDxLaW5kIGV4dGVuZHMgVW5pc3RQYXJlbnQ+KHBhcmVudDogS2luZCwgaW5kZXhTdGFydDogQ2hpbGQ8S2luZD4gfCBudW1iZXIsIGluZGV4RW5kOiBDaGlsZDxLaW5kPiB8IG51bWJlciwgdGVzdD86IG51bGwgfCB1bmRlZmluZWQsIG9wdGlvbnM/OiBCZWhhdmlvdXIpID0+IEFycmF5PENoaWxkPEtpbmQ+PilcbiAqICl9XG4gKi9cbihcbi8qKlxuICogQHR5cGVkZWYgeyh7YmVoYXZpb3VyIDogXCJpbmNsdWRlXCIgfCBcImV4Y2x1ZGVcIn0pfSBCZWhhdmlvdXJcbiAqIHdoZXRoZXIgbm9kZXMgYW5kIGluZGV4ZXMgYXRoIGJvdGggc2lkZXMgaW5jbHVkZWQgb3IgZXhjdWx1ZGVkLlxuICogZGVmYXVsdCBiZWhhdmlvdXIgaXMgZXhjbHVkZWQgb25lLlxuICovXG4vKipcbiAqIEBwYXJhbSB7VW5pc3RQYXJlbnR9IHBhcmVudFxuICogQHBhcmFtIHtVbmlzdE5vZGUgfCBudW1iZXJ9IGluZGV4U3RhcnRcbiAqIEBwYXJhbSB7VW5pc3ROb2RlIHwgbnVtYmVyfSBpbmRleEVuZFxuICogQHBhcmFtIHtUZXN0fSBbdGVzdF1cbiAqIEBwYXJhbSB7dW5kZWZpbmVkIHwgQmVoYXZpb3VyfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtBcnJheTxVbmlzdE5vZGU+fVxuICovXG4vKiBlc2xpbnQgbWF4LXBhcmFtczogW1wiZXJyb3JcIiwgNV0gKi9cbmZ1bmN0aW9uIChwYXJlbnQsIGluZGV4U3RhcnQsIGluZGV4RW5kLCB0ZXN0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgaXMgPSBjb252ZXJ0KHRlc3QpO1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8VW5pc3ROb2RlPn0gKi9cbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgaWYgKCFwYXJlbnQgfHwgIXBhcmVudC50eXBlIHx8ICFwYXJlbnQuY2hpbGRyZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwYXJlbnQgbm9kZScpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGluZGV4U3RhcnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChpbmRleFN0YXJ0IDwgMCB8fCBpbmRleFN0YXJ0ID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG9zaXRpdmUgZmluaXRlIG51bWJlciBhcyBpbmRleCBmb3Igc3RhcnQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaW5kZXhTdGFydCA9IHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKGluZGV4U3RhcnQpO1xuICAgICAgICBpZiAoaW5kZXhTdGFydCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgY2hpbGQgbm9kZSBvciBpbmRleCBmb3Igc3RhcnQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGluZGV4RW5kID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoaW5kZXhFbmQgPCAwIHx8IGluZGV4RW5kID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG9zaXRpdmUgZmluaXRlIG51bWJlciBhcyBpbmRleCBmb3IgZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGluZGV4RW5kID0gcGFyZW50LmNoaWxkcmVuLmluZGV4T2YoaW5kZXhFbmQpO1xuICAgICAgICBpZiAoaW5kZXhFbmQgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGNoaWxkIG5vZGUgb3IgaW5kZXggZm9yIGVuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zPy5iZWhhdmlvdXIgPT09ICdpbmNsdWRlJykge1xuICAgICAgICB3aGlsZSAoaW5kZXhTdGFydCA8PSBpbmRleEVuZCkge1xuICAgICAgICAgICAgaWYgKGlzKHBhcmVudC5jaGlsZHJlbltpbmRleFN0YXJ0XSwgaW5kZXhTdGFydCwgcGFyZW50KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChwYXJlbnQuY2hpbGRyZW5baW5kZXhTdGFydF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXhTdGFydCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3aGlsZSAoKytpbmRleFN0YXJ0IDwgaW5kZXhFbmQpIHtcbiAgICAgICAgICAgIGlmIChpcyhwYXJlbnQuY2hpbGRyZW5baW5kZXhTdGFydF0sIGluZGV4U3RhcnQsIHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocGFyZW50LmNoaWxkcmVuW2luZGV4U3RhcnRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbn0pO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/unist-util-find-between-all/dist/lib/index.js\n");

/***/ })

};
;