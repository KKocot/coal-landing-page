"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/remark-flexible-paragraphs";
exports.ids = ["vendor-chunks/remark-flexible-paragraphs"];
exports.modules = {

/***/ "(ssr)/./node_modules/remark-flexible-paragraphs/dist/esm/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/remark-flexible-paragraphs/dist/esm/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   REGEX: () => (/* binding */ REGEX),\n/* harmony export */   REGEX_GLOBAL: () => (/* binding */ REGEX_GLOBAL),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   plugin: () => (/* binding */ plugin)\n/* harmony export */ });\n/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-visit */ \"(ssr)/./node_modules/unist-util-visit/lib/index.js\");\n/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! unist-util-visit */ \"(ssr)/./node_modules/unist-util-visit-parents/lib/index.js\");\n/* harmony import */ var unist_builder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! unist-builder */ \"(ssr)/./node_modules/unist-builder/lib/index.js\");\n\n\nconst dictionary = {\n    a: \"alert\",\n    b: \"blue\",\n    c: \"caution\",\n    d: \"danger\",\n    e: \"error\",\n    f: \"framed\",\n    g: \"green\",\n    h: \"horizontal\",\n    i: \"info\",\n    j: \"jumbo\",\n    k: \"kindle\",\n    l: \"lokum\",\n    m: \"menu\",\n    n: \"note\",\n    o: \"ordinary\",\n    p: \"pack\",\n    q: \"quantity\",\n    r: \"red\",\n    s: \"success\",\n    t: \"tip\",\n    u: \"unified\",\n    v: \"verticle\",\n    w: \"warning\",\n    x: \"xray\",\n    y: \"yellow\",\n    z: \"zigzag\",\n    \"0\": \"type-0\",\n    \"1\": \"type-1\",\n    \"2\": \"type-2\",\n    \"3\": \"type-3\",\n    \"4\": \"type-4\",\n    \"5\": \"type-5\",\n    \"6\": \"type-6\",\n    \"7\": \"type-7\",\n    \"8\": \"type-8\",\n    \"9\": \"type-9\",\n};\nconst DEFAULT_SETTINGS = {\n    dictionary,\n    paragraphClassName: \"flexible-paragraph\",\n    paragraphClassificationPrefix: \"flexiparaph\",\n    wrapperTagName: \"div\",\n    wrapperClassName: \"flexible-paragraph-wrapper\",\n};\nconst REGEX = /([~=])(:)?([a-z0-9]*\\|?[a-z0-9]*)?(:)?>\\s*/;\nconst REGEX_GLOBAL = /([~=])(:)?([a-z0-9]*\\|?[a-z0-9]*)?(:)?>\\s*/g;\n/**\n *\n * This plugin turns a paragraph into a flexible paragraph or splits it as a flexible paragraph,\n * with optional wrapper, customizable classifications and customizable alignment\n *\n * for example:\n *\n * ~> I am a flexible paragraph\n * => I am a flexible paragraph wrapped in a div\n *\n */\nconst plugin = (options) => {\n    const settings = Object.assign({}, DEFAULT_SETTINGS, options);\n    if (options?.dictionary && Object.keys(options.dictionary).length) {\n        settings.dictionary = Object.assign({}, dictionary, options.dictionary);\n    }\n    /**\n     *\n     * constracts the paragraph node\n     *\n     */\n    const constructParagraph = (phrasingContents, classifications, alignment) => {\n        const classnames = [];\n        classifications.forEach((classification) => {\n            classnames.push(settings.paragraphClassificationPrefix === \"\"\n                ? `${classification}`\n                : `${settings.paragraphClassificationPrefix}-${classification}`);\n        });\n        if (alignment) {\n            classnames.push(settings.paragraphClassificationPrefix === \"\"\n                ? `align-${alignment}`\n                : `${settings.paragraphClassificationPrefix}-align-${alignment}`);\n        }\n        const paragraphClassName = typeof settings.paragraphClassName === \"function\"\n            ? settings.paragraphClassName(alignment, classifications)\n            : [settings.paragraphClassName, ...classnames];\n        let properties;\n        if (settings.paragraphProperties) {\n            properties = settings.paragraphProperties(alignment, classifications);\n            Object.entries(properties).forEach(([k, v]) => {\n                if ((typeof v === \"string\" && v === \"\") ||\n                    (Array.isArray(v) && v.length === 0)) {\n                    if (properties) {\n                        properties[k] = undefined;\n                    }\n                }\n                if (k === \"className\")\n                    delete properties?.[\"className\"];\n            });\n        }\n        return {\n            type: \"paragraph\",\n            children: phrasingContents,\n            data: {\n                hName: \"p\",\n                hProperties: {\n                    className: paragraphClassName,\n                    ...(properties && { ...properties }),\n                    style: alignment ? `text-align:${alignment}` : undefined,\n                },\n            },\n        };\n    };\n    /**\n     *\n     * constracts the wrapper node\n     *\n     */\n    const constructWrapper = (paragraph, classifications, alignment) => {\n        const wrapperTagName = typeof settings.wrapperTagName === \"string\"\n            ? settings.wrapperTagName\n            : settings.wrapperTagName(alignment, classifications);\n        const wrapperClassName = typeof settings.wrapperClassName === \"function\"\n            ? settings.wrapperClassName(alignment, classifications)\n            : [settings.wrapperClassName];\n        let properties;\n        if (settings.wrapperProperties) {\n            properties = settings.wrapperProperties(alignment, classifications);\n            Object.entries(properties).forEach(([k, v]) => {\n                if ((typeof v === \"string\" && v === \"\") ||\n                    (Array.isArray(v) && v.length === 0)) {\n                    if (properties) {\n                        properties[k] = undefined;\n                    }\n                }\n                if (k === \"className\")\n                    delete properties?.[\"className\"];\n            });\n        }\n        return {\n            type: \"wrapper\",\n            children: [paragraph],\n            data: {\n                hName: wrapperTagName,\n                hProperties: {\n                    className: wrapperClassName,\n                    ...(properties && { ...properties }),\n                },\n            },\n        };\n    };\n    /**\n     *\n     * checks whether the paragraph node contains a text node which has a regex match.\n     *\n     */\n    function checkIsTarget(node) {\n        let isTarget = false;\n        (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_0__.visit)(node, \"text\", (textNode) => {\n            if (!REGEX.test(textNode.value))\n                return;\n            isTarget = true;\n            return unist_util_visit__WEBPACK_IMPORTED_MODULE_1__.EXIT;\n        });\n        return isTarget;\n    }\n    /**\n     *\n     * returns the array with added value, handles if the array is undefined\n     *\n     */\n    function insert(array, phrasingContent) {\n        if (typeof array === \"undefined\") {\n            array = [phrasingContent];\n        }\n        else {\n            array.push(phrasingContent);\n        }\n        return array;\n    }\n    /**\n     *\n     * returns the extracted info about flexible paragraph from the match\n     *\n     */\n    function getFlexibleNode({ marker, left, classes, right, }) {\n        let _alignment;\n        if (!left && !right) {\n            _alignment = undefined;\n        }\n        else if (left && right) {\n            _alignment = \"justify\";\n        }\n        else if (left) {\n            _alignment = \"left\";\n        }\n        else if (right) {\n            _alignment = \"right\";\n        }\n        if (classes?.includes(\"|\")) {\n            _alignment = \"center\";\n        }\n        if (classes === \"|\") {\n            if (left && right) {\n                _alignment = \"justify\";\n            }\n            else if (left) {\n                _alignment = \"left\";\n            }\n            else if (right) {\n                _alignment = \"right\";\n            }\n        }\n        const markers = {\n            \"=\": \"wrapper\",\n            \"~\": \"paragraph\",\n        };\n        const type = markers[marker];\n        const alignment = _alignment;\n        const classifications = classes\n            ? Array.from(classes).reduce((list, char) => {\n                if (char !== \"|\") {\n                    const name = settings.dictionary[char];\n                    if (name)\n                        list.push(name);\n                }\n                return list;\n            }, [])\n            : [];\n        return { type, alignment, classifications };\n    }\n    /**\n     *\n     * type guard\n     *\n     */\n    const isTextNode = (node) => {\n        return \"value\" in node && node.type === \"text\";\n    };\n    /**\n     *\n     * visits the Paragraph nodes\n     *\n     */\n    const visitor = function (node, index, parent) {\n        /* v8 ignore next */\n        if (!parent || typeof index === \"undefined\")\n            return;\n        const isTarget = checkIsTarget(node);\n        if (!isTarget)\n            return;\n        const nodes = [];\n        const phrasesMatrix = [[]];\n        const flexibleNodes = [];\n        let matrixIndex = 0;\n        // traverse the paragraph looking for the markers\n        for (const phrasingContent of node.children) {\n            if (!isTextNode(phrasingContent)) {\n                phrasesMatrix[matrixIndex] = insert(phrasesMatrix[matrixIndex], phrasingContent);\n            }\n            else {\n                const value = phrasingContent.value;\n                // console.log(\"value: \", JSON.stringify(value));\n                // console.log(Array.from(value.matchAll(REGEX_GLOBAL), (m) => m[0]));\n                const matches = Array.from(value.matchAll(REGEX_GLOBAL));\n                if (!matches.length) {\n                    phrasesMatrix[matrixIndex] = insert(phrasesMatrix[matrixIndex], phrasingContent);\n                }\n                else {\n                    for (let idx = 0; idx < matches.length; idx++) {\n                        const match = matches[idx];\n                        const [matched, marker, left, classes, right] = match;\n                        const mIndex = match.index;\n                        const mLength = matched.length;\n                        // if it is the first match but the marker index is not first\n                        if (idx === 0 && mIndex !== 0) {\n                            const textValue = value.substring(0, mIndex);\n                            if (textValue) {\n                                const text = (0,unist_builder__WEBPACK_IMPORTED_MODULE_2__.u)(\"text\", textValue);\n                                phrasesMatrix[matrixIndex] = insert(phrasesMatrix[matrixIndex], text);\n                            }\n                        }\n                        // do not increase matrixIndex if the marker is in the first phrase in the beginning\n                        if (idx !== 0 || mIndex !== 0)\n                            matrixIndex++;\n                        const textValue = idx === matches.length - 1\n                            ? // if it is the last match\n                                value.slice(mIndex + mLength)\n                            : // if it is NOT the last match\n                                value.substring(mIndex + mLength, matches[idx + 1].index);\n                        if (textValue) {\n                            const text = (0,unist_builder__WEBPACK_IMPORTED_MODULE_2__.u)(\"text\", textValue);\n                            phrasesMatrix[matrixIndex] = insert(phrasesMatrix[matrixIndex], text);\n                        }\n                        flexibleNodes[matrixIndex] = getFlexibleNode({\n                            marker, // \"=\" or \"~\"\n                            left,\n                            classes,\n                            right,\n                        });\n                    }\n                }\n            }\n        }\n        // clean the newline and spaces at the last phrases (if Text) of each flexible paragraph\n        phrasesMatrix.forEach((phrasingContents) => {\n            const lastPhrase = phrasingContents[phrasingContents.length - 1];\n            if (lastPhrase.type === \"text\") {\n                lastPhrase.value = lastPhrase.value.replace(/[\\s\\r\\n]+$/, \"\");\n            }\n        });\n        // construct the flexible paragraphs whether in a wrapper or not\n        phrasesMatrix.forEach((phrasingContents, i) => {\n            const paragraph = flexibleNodes[i]\n                ? constructParagraph(phrasingContents, flexibleNodes[i].classifications, flexibleNodes[i].alignment)\n                : (0,unist_builder__WEBPACK_IMPORTED_MODULE_2__.u)(\"paragraph\", phrasingContents);\n            if (flexibleNodes[i]?.type === \"wrapper\") {\n                const wrapper = constructWrapper(paragraph, flexibleNodes[i].classifications, flexibleNodes[i].alignment);\n                nodes.push(wrapper);\n            }\n            else {\n                nodes.push(paragraph);\n            }\n        });\n        if (nodes.length)\n            parent.children.splice(index, 1, ...nodes);\n    };\n    const transformer = (tree) => {\n        (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_0__.visit)(tree, \"paragraph\", visitor);\n    };\n    return transformer;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVtYXJrLWZsZXhpYmxlLXBhcmFncmFwaHMvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUErQztBQUNiO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxxQ0FBcUM7QUFDckM7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQyxxQkFBcUIsdUNBQXVDLEdBQUcsZUFBZTtBQUM5RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDLHFCQUFxQix1Q0FBdUMsU0FBUyxVQUFVO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZUFBZTtBQUN2RCxxREFBcUQsVUFBVTtBQUMvRCxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxlQUFlO0FBQ3ZELGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBSztBQUNiO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrREFBSTtBQUN2QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLCtCQUErQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxzQkFBc0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnREFBQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0RBQUM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0RBQUM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFLO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsTUFBTSxFQUFDO0FBQ3RCIiwic291cmNlcyI6WyIvVXNlcnMva3J6eXN6dG9ma29jb3QvRGVza3RvcC9sYW5kaW5nLXBhZ2Uvbm9kZV9tb2R1bGVzL3JlbWFyay1mbGV4aWJsZS1wYXJhZ3JhcGhzL2Rpc3QvZXNtL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHZpc2l0LCBFWElUIH0gZnJvbSBcInVuaXN0LXV0aWwtdmlzaXRcIjtcbmltcG9ydCB7IHUgfSBmcm9tIFwidW5pc3QtYnVpbGRlclwiO1xuY29uc3QgZGljdGlvbmFyeSA9IHtcbiAgICBhOiBcImFsZXJ0XCIsXG4gICAgYjogXCJibHVlXCIsXG4gICAgYzogXCJjYXV0aW9uXCIsXG4gICAgZDogXCJkYW5nZXJcIixcbiAgICBlOiBcImVycm9yXCIsXG4gICAgZjogXCJmcmFtZWRcIixcbiAgICBnOiBcImdyZWVuXCIsXG4gICAgaDogXCJob3Jpem9udGFsXCIsXG4gICAgaTogXCJpbmZvXCIsXG4gICAgajogXCJqdW1ib1wiLFxuICAgIGs6IFwia2luZGxlXCIsXG4gICAgbDogXCJsb2t1bVwiLFxuICAgIG06IFwibWVudVwiLFxuICAgIG46IFwibm90ZVwiLFxuICAgIG86IFwib3JkaW5hcnlcIixcbiAgICBwOiBcInBhY2tcIixcbiAgICBxOiBcInF1YW50aXR5XCIsXG4gICAgcjogXCJyZWRcIixcbiAgICBzOiBcInN1Y2Nlc3NcIixcbiAgICB0OiBcInRpcFwiLFxuICAgIHU6IFwidW5pZmllZFwiLFxuICAgIHY6IFwidmVydGljbGVcIixcbiAgICB3OiBcIndhcm5pbmdcIixcbiAgICB4OiBcInhyYXlcIixcbiAgICB5OiBcInllbGxvd1wiLFxuICAgIHo6IFwiemlnemFnXCIsXG4gICAgXCIwXCI6IFwidHlwZS0wXCIsXG4gICAgXCIxXCI6IFwidHlwZS0xXCIsXG4gICAgXCIyXCI6IFwidHlwZS0yXCIsXG4gICAgXCIzXCI6IFwidHlwZS0zXCIsXG4gICAgXCI0XCI6IFwidHlwZS00XCIsXG4gICAgXCI1XCI6IFwidHlwZS01XCIsXG4gICAgXCI2XCI6IFwidHlwZS02XCIsXG4gICAgXCI3XCI6IFwidHlwZS03XCIsXG4gICAgXCI4XCI6IFwidHlwZS04XCIsXG4gICAgXCI5XCI6IFwidHlwZS05XCIsXG59O1xuY29uc3QgREVGQVVMVF9TRVRUSU5HUyA9IHtcbiAgICBkaWN0aW9uYXJ5LFxuICAgIHBhcmFncmFwaENsYXNzTmFtZTogXCJmbGV4aWJsZS1wYXJhZ3JhcGhcIixcbiAgICBwYXJhZ3JhcGhDbGFzc2lmaWNhdGlvblByZWZpeDogXCJmbGV4aXBhcmFwaFwiLFxuICAgIHdyYXBwZXJUYWdOYW1lOiBcImRpdlwiLFxuICAgIHdyYXBwZXJDbGFzc05hbWU6IFwiZmxleGlibGUtcGFyYWdyYXBoLXdyYXBwZXJcIixcbn07XG5leHBvcnQgY29uc3QgUkVHRVggPSAvKFt+PV0pKDopPyhbYS16MC05XSpcXHw/W2EtejAtOV0qKT8oOik/PlxccyovO1xuZXhwb3J0IGNvbnN0IFJFR0VYX0dMT0JBTCA9IC8oW349XSkoOik/KFthLXowLTldKlxcfD9bYS16MC05XSopPyg6KT8+XFxzKi9nO1xuLyoqXG4gKlxuICogVGhpcyBwbHVnaW4gdHVybnMgYSBwYXJhZ3JhcGggaW50byBhIGZsZXhpYmxlIHBhcmFncmFwaCBvciBzcGxpdHMgaXQgYXMgYSBmbGV4aWJsZSBwYXJhZ3JhcGgsXG4gKiB3aXRoIG9wdGlvbmFsIHdyYXBwZXIsIGN1c3RvbWl6YWJsZSBjbGFzc2lmaWNhdGlvbnMgYW5kIGN1c3RvbWl6YWJsZSBhbGlnbm1lbnRcbiAqXG4gKiBmb3IgZXhhbXBsZTpcbiAqXG4gKiB+PiBJIGFtIGEgZmxleGlibGUgcGFyYWdyYXBoXG4gKiA9PiBJIGFtIGEgZmxleGlibGUgcGFyYWdyYXBoIHdyYXBwZWQgaW4gYSBkaXZcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBwbHVnaW4gPSAob3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnM/LmRpY3Rpb25hcnkgJiYgT2JqZWN0LmtleXMob3B0aW9ucy5kaWN0aW9uYXJ5KS5sZW5ndGgpIHtcbiAgICAgICAgc2V0dGluZ3MuZGljdGlvbmFyeSA9IE9iamVjdC5hc3NpZ24oe30sIGRpY3Rpb25hcnksIG9wdGlvbnMuZGljdGlvbmFyeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogY29uc3RyYWN0cyB0aGUgcGFyYWdyYXBoIG5vZGVcbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0IGNvbnN0cnVjdFBhcmFncmFwaCA9IChwaHJhc2luZ0NvbnRlbnRzLCBjbGFzc2lmaWNhdGlvbnMsIGFsaWdubWVudCkgPT4ge1xuICAgICAgICBjb25zdCBjbGFzc25hbWVzID0gW107XG4gICAgICAgIGNsYXNzaWZpY2F0aW9ucy5mb3JFYWNoKChjbGFzc2lmaWNhdGlvbikgPT4ge1xuICAgICAgICAgICAgY2xhc3NuYW1lcy5wdXNoKHNldHRpbmdzLnBhcmFncmFwaENsYXNzaWZpY2F0aW9uUHJlZml4ID09PSBcIlwiXG4gICAgICAgICAgICAgICAgPyBgJHtjbGFzc2lmaWNhdGlvbn1gXG4gICAgICAgICAgICAgICAgOiBgJHtzZXR0aW5ncy5wYXJhZ3JhcGhDbGFzc2lmaWNhdGlvblByZWZpeH0tJHtjbGFzc2lmaWNhdGlvbn1gKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhbGlnbm1lbnQpIHtcbiAgICAgICAgICAgIGNsYXNzbmFtZXMucHVzaChzZXR0aW5ncy5wYXJhZ3JhcGhDbGFzc2lmaWNhdGlvblByZWZpeCA9PT0gXCJcIlxuICAgICAgICAgICAgICAgID8gYGFsaWduLSR7YWxpZ25tZW50fWBcbiAgICAgICAgICAgICAgICA6IGAke3NldHRpbmdzLnBhcmFncmFwaENsYXNzaWZpY2F0aW9uUHJlZml4fS1hbGlnbi0ke2FsaWdubWVudH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhZ3JhcGhDbGFzc05hbWUgPSB0eXBlb2Ygc2V0dGluZ3MucGFyYWdyYXBoQ2xhc3NOYW1lID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gc2V0dGluZ3MucGFyYWdyYXBoQ2xhc3NOYW1lKGFsaWdubWVudCwgY2xhc3NpZmljYXRpb25zKVxuICAgICAgICAgICAgOiBbc2V0dGluZ3MucGFyYWdyYXBoQ2xhc3NOYW1lLCAuLi5jbGFzc25hbWVzXTtcbiAgICAgICAgbGV0IHByb3BlcnRpZXM7XG4gICAgICAgIGlmIChzZXR0aW5ncy5wYXJhZ3JhcGhQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0gc2V0dGluZ3MucGFyYWdyYXBoUHJvcGVydGllcyhhbGlnbm1lbnQsIGNsYXNzaWZpY2F0aW9ucyk7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhwcm9wZXJ0aWVzKS5mb3JFYWNoKChbaywgdl0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiICYmIHYgPT09IFwiXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgIChBcnJheS5pc0FycmF5KHYpICYmIHYubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllc1trXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gXCJjbGFzc05hbWVcIilcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHByb3BlcnRpZXM/LltcImNsYXNzTmFtZVwiXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcInBhcmFncmFwaFwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IHBocmFzaW5nQ29udGVudHMsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgaE5hbWU6IFwicFwiLFxuICAgICAgICAgICAgICAgIGhQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogcGFyYWdyYXBoQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgICAgICAuLi4ocHJvcGVydGllcyAmJiB7IC4uLnByb3BlcnRpZXMgfSksXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBhbGlnbm1lbnQgPyBgdGV4dC1hbGlnbjoke2FsaWdubWVudH1gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBjb25zdHJhY3RzIHRoZSB3cmFwcGVyIG5vZGVcbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0IGNvbnN0cnVjdFdyYXBwZXIgPSAocGFyYWdyYXBoLCBjbGFzc2lmaWNhdGlvbnMsIGFsaWdubWVudCkgPT4ge1xuICAgICAgICBjb25zdCB3cmFwcGVyVGFnTmFtZSA9IHR5cGVvZiBzZXR0aW5ncy53cmFwcGVyVGFnTmFtZSA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgPyBzZXR0aW5ncy53cmFwcGVyVGFnTmFtZVxuICAgICAgICAgICAgOiBzZXR0aW5ncy53cmFwcGVyVGFnTmFtZShhbGlnbm1lbnQsIGNsYXNzaWZpY2F0aW9ucyk7XG4gICAgICAgIGNvbnN0IHdyYXBwZXJDbGFzc05hbWUgPSB0eXBlb2Ygc2V0dGluZ3Mud3JhcHBlckNsYXNzTmFtZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICA/IHNldHRpbmdzLndyYXBwZXJDbGFzc05hbWUoYWxpZ25tZW50LCBjbGFzc2lmaWNhdGlvbnMpXG4gICAgICAgICAgICA6IFtzZXR0aW5ncy53cmFwcGVyQ2xhc3NOYW1lXTtcbiAgICAgICAgbGV0IHByb3BlcnRpZXM7XG4gICAgICAgIGlmIChzZXR0aW5ncy53cmFwcGVyUHJvcGVydGllcykge1xuICAgICAgICAgICAgcHJvcGVydGllcyA9IHNldHRpbmdzLndyYXBwZXJQcm9wZXJ0aWVzKGFsaWdubWVudCwgY2xhc3NpZmljYXRpb25zKTtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHByb3BlcnRpZXMpLmZvckVhY2goKFtrLCB2XSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIHYgPT09IFwic3RyaW5nXCIgJiYgdiA9PT0gXCJcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkodikgJiYgdi5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2tdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrID09PSBcImNsYXNzTmFtZVwiKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcHJvcGVydGllcz8uW1wiY2xhc3NOYW1lXCJdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwid3JhcHBlclwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtwYXJhZ3JhcGhdLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGhOYW1lOiB3cmFwcGVyVGFnTmFtZSxcbiAgICAgICAgICAgICAgICBoUHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHdyYXBwZXJDbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgICAgIC4uLihwcm9wZXJ0aWVzICYmIHsgLi4ucHJvcGVydGllcyB9KSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogY2hlY2tzIHdoZXRoZXIgdGhlIHBhcmFncmFwaCBub2RlIGNvbnRhaW5zIGEgdGV4dCBub2RlIHdoaWNoIGhhcyBhIHJlZ2V4IG1hdGNoLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hlY2tJc1RhcmdldChub2RlKSB7XG4gICAgICAgIGxldCBpc1RhcmdldCA9IGZhbHNlO1xuICAgICAgICB2aXNpdChub2RlLCBcInRleHRcIiwgKHRleHROb2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIVJFR0VYLnRlc3QodGV4dE5vZGUudmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlzVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBFWElUO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGlzVGFyZ2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIHJldHVybnMgdGhlIGFycmF5IHdpdGggYWRkZWQgdmFsdWUsIGhhbmRsZXMgaWYgdGhlIGFycmF5IGlzIHVuZGVmaW5lZFxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zZXJ0KGFycmF5LCBwaHJhc2luZ0NvbnRlbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcnJheSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgYXJyYXkgPSBbcGhyYXNpbmdDb250ZW50XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5LnB1c2gocGhyYXNpbmdDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogcmV0dXJucyB0aGUgZXh0cmFjdGVkIGluZm8gYWJvdXQgZmxleGlibGUgcGFyYWdyYXBoIGZyb20gdGhlIG1hdGNoXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRGbGV4aWJsZU5vZGUoeyBtYXJrZXIsIGxlZnQsIGNsYXNzZXMsIHJpZ2h0LCB9KSB7XG4gICAgICAgIGxldCBfYWxpZ25tZW50O1xuICAgICAgICBpZiAoIWxlZnQgJiYgIXJpZ2h0KSB7XG4gICAgICAgICAgICBfYWxpZ25tZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlZnQgJiYgcmlnaHQpIHtcbiAgICAgICAgICAgIF9hbGlnbm1lbnQgPSBcImp1c3RpZnlcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZWZ0KSB7XG4gICAgICAgICAgICBfYWxpZ25tZW50ID0gXCJsZWZ0XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmlnaHQpIHtcbiAgICAgICAgICAgIF9hbGlnbm1lbnQgPSBcInJpZ2h0XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYXNzZXM/LmluY2x1ZGVzKFwifFwiKSkge1xuICAgICAgICAgICAgX2FsaWdubWVudCA9IFwiY2VudGVyXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYXNzZXMgPT09IFwifFwiKSB7XG4gICAgICAgICAgICBpZiAobGVmdCAmJiByaWdodCkge1xuICAgICAgICAgICAgICAgIF9hbGlnbm1lbnQgPSBcImp1c3RpZnlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlZnQpIHtcbiAgICAgICAgICAgICAgICBfYWxpZ25tZW50ID0gXCJsZWZ0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyaWdodCkge1xuICAgICAgICAgICAgICAgIF9hbGlnbm1lbnQgPSBcInJpZ2h0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFya2VycyA9IHtcbiAgICAgICAgICAgIFwiPVwiOiBcIndyYXBwZXJcIixcbiAgICAgICAgICAgIFwiflwiOiBcInBhcmFncmFwaFwiLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0eXBlID0gbWFya2Vyc1ttYXJrZXJdO1xuICAgICAgICBjb25zdCBhbGlnbm1lbnQgPSBfYWxpZ25tZW50O1xuICAgICAgICBjb25zdCBjbGFzc2lmaWNhdGlvbnMgPSBjbGFzc2VzXG4gICAgICAgICAgICA/IEFycmF5LmZyb20oY2xhc3NlcykucmVkdWNlKChsaXN0LCBjaGFyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXIgIT09IFwifFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBzZXR0aW5ncy5kaWN0aW9uYXJ5W2NoYXJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaChuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICAgICAgICB9LCBbXSlcbiAgICAgICAgICAgIDogW107XG4gICAgICAgIHJldHVybiB7IHR5cGUsIGFsaWdubWVudCwgY2xhc3NpZmljYXRpb25zIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogdHlwZSBndWFyZFxuICAgICAqXG4gICAgICovXG4gICAgY29uc3QgaXNUZXh0Tm9kZSA9IChub2RlKSA9PiB7XG4gICAgICAgIHJldHVybiBcInZhbHVlXCIgaW4gbm9kZSAmJiBub2RlLnR5cGUgPT09IFwidGV4dFwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiB2aXNpdHMgdGhlIFBhcmFncmFwaCBub2Rlc1xuICAgICAqXG4gICAgICovXG4gICAgY29uc3QgdmlzaXRvciA9IGZ1bmN0aW9uIChub2RlLCBpbmRleCwgcGFyZW50KSB7XG4gICAgICAgIC8qIHY4IGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmICghcGFyZW50IHx8IHR5cGVvZiBpbmRleCA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgaXNUYXJnZXQgPSBjaGVja0lzVGFyZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoIWlzVGFyZ2V0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgICAgICBjb25zdCBwaHJhc2VzTWF0cml4ID0gW1tdXTtcbiAgICAgICAgY29uc3QgZmxleGlibGVOb2RlcyA9IFtdO1xuICAgICAgICBsZXQgbWF0cml4SW5kZXggPSAwO1xuICAgICAgICAvLyB0cmF2ZXJzZSB0aGUgcGFyYWdyYXBoIGxvb2tpbmcgZm9yIHRoZSBtYXJrZXJzXG4gICAgICAgIGZvciAoY29uc3QgcGhyYXNpbmdDb250ZW50IG9mIG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmICghaXNUZXh0Tm9kZShwaHJhc2luZ0NvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgcGhyYXNlc01hdHJpeFttYXRyaXhJbmRleF0gPSBpbnNlcnQocGhyYXNlc01hdHJpeFttYXRyaXhJbmRleF0sIHBocmFzaW5nQ29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBocmFzaW5nQ29udGVudC52YWx1ZTtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInZhbHVlOiBcIiwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhBcnJheS5mcm9tKHZhbHVlLm1hdGNoQWxsKFJFR0VYX0dMT0JBTCksIChtKSA9PiBtWzBdKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IEFycmF5LmZyb20odmFsdWUubWF0Y2hBbGwoUkVHRVhfR0xPQkFMKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwaHJhc2VzTWF0cml4W21hdHJpeEluZGV4XSA9IGluc2VydChwaHJhc2VzTWF0cml4W21hdHJpeEluZGV4XSwgcGhyYXNpbmdDb250ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IG1hdGNoZXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBtYXRjaGVzW2lkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbbWF0Y2hlZCwgbWFya2VyLCBsZWZ0LCBjbGFzc2VzLCByaWdodF0gPSBtYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1JbmRleCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbUxlbmd0aCA9IG1hdGNoZWQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXQgaXMgdGhlIGZpcnN0IG1hdGNoIGJ1dCB0aGUgbWFya2VyIGluZGV4IGlzIG5vdCBmaXJzdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA9PT0gMCAmJiBtSW5kZXggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0VmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgbUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSB1KFwidGV4dFwiLCB0ZXh0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaHJhc2VzTWF0cml4W21hdHJpeEluZGV4XSA9IGluc2VydChwaHJhc2VzTWF0cml4W21hdHJpeEluZGV4XSwgdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IGluY3JlYXNlIG1hdHJpeEluZGV4IGlmIHRoZSBtYXJrZXIgaXMgaW4gdGhlIGZpcnN0IHBocmFzZSBpbiB0aGUgYmVnaW5uaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ICE9PSAwIHx8IG1JbmRleCAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXhJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dFZhbHVlID0gaWR4ID09PSBtYXRjaGVzLmxlbmd0aCAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IC8vIGlmIGl0IGlzIHRoZSBsYXN0IG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnNsaWNlKG1JbmRleCArIG1MZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAvLyBpZiBpdCBpcyBOT1QgdGhlIGxhc3QgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc3Vic3RyaW5nKG1JbmRleCArIG1MZW5ndGgsIG1hdGNoZXNbaWR4ICsgMV0uaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSB1KFwidGV4dFwiLCB0ZXh0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBocmFzZXNNYXRyaXhbbWF0cml4SW5kZXhdID0gaW5zZXJ0KHBocmFzZXNNYXRyaXhbbWF0cml4SW5kZXhdLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZsZXhpYmxlTm9kZXNbbWF0cml4SW5kZXhdID0gZ2V0RmxleGlibGVOb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXIsIC8vIFwiPVwiIG9yIFwiflwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2xlYW4gdGhlIG5ld2xpbmUgYW5kIHNwYWNlcyBhdCB0aGUgbGFzdCBwaHJhc2VzIChpZiBUZXh0KSBvZiBlYWNoIGZsZXhpYmxlIHBhcmFncmFwaFxuICAgICAgICBwaHJhc2VzTWF0cml4LmZvckVhY2goKHBocmFzaW5nQ29udGVudHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RQaHJhc2UgPSBwaHJhc2luZ0NvbnRlbnRzW3BocmFzaW5nQ29udGVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAobGFzdFBocmFzZS50eXBlID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgICAgIGxhc3RQaHJhc2UudmFsdWUgPSBsYXN0UGhyYXNlLnZhbHVlLnJlcGxhY2UoL1tcXHNcXHJcXG5dKyQvLCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGNvbnN0cnVjdCB0aGUgZmxleGlibGUgcGFyYWdyYXBocyB3aGV0aGVyIGluIGEgd3JhcHBlciBvciBub3RcbiAgICAgICAgcGhyYXNlc01hdHJpeC5mb3JFYWNoKChwaHJhc2luZ0NvbnRlbnRzLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJhZ3JhcGggPSBmbGV4aWJsZU5vZGVzW2ldXG4gICAgICAgICAgICAgICAgPyBjb25zdHJ1Y3RQYXJhZ3JhcGgocGhyYXNpbmdDb250ZW50cywgZmxleGlibGVOb2Rlc1tpXS5jbGFzc2lmaWNhdGlvbnMsIGZsZXhpYmxlTm9kZXNbaV0uYWxpZ25tZW50KVxuICAgICAgICAgICAgICAgIDogdShcInBhcmFncmFwaFwiLCBwaHJhc2luZ0NvbnRlbnRzKTtcbiAgICAgICAgICAgIGlmIChmbGV4aWJsZU5vZGVzW2ldPy50eXBlID09PSBcIndyYXBwZXJcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSBjb25zdHJ1Y3RXcmFwcGVyKHBhcmFncmFwaCwgZmxleGlibGVOb2Rlc1tpXS5jbGFzc2lmaWNhdGlvbnMsIGZsZXhpYmxlTm9kZXNbaV0uYWxpZ25tZW50KTtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKHdyYXBwZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChwYXJhZ3JhcGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aClcbiAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEsIC4uLm5vZGVzKTtcbiAgICB9O1xuICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gKHRyZWUpID0+IHtcbiAgICAgICAgdmlzaXQodHJlZSwgXCJwYXJhZ3JhcGhcIiwgdmlzaXRvcik7XG4gICAgfTtcbiAgICByZXR1cm4gdHJhbnNmb3JtZXI7XG59O1xuZXhwb3J0IGRlZmF1bHQgcGx1Z2luO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/remark-flexible-paragraphs/dist/esm/index.js\n");

/***/ })

};
;