"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/remark-flexible-markers";
exports.ids = ["vendor-chunks/remark-flexible-markers"];
exports.modules = {

/***/ "(ssr)/./node_modules/remark-flexible-markers/dist/esm/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/remark-flexible-markers/dist/esm/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   REGEX: () => (/* binding */ REGEX),\n/* harmony export */   REGEX_EMPTY: () => (/* binding */ REGEX_EMPTY),\n/* harmony export */   REGEX_EMPTY_GLOBAL: () => (/* binding */ REGEX_EMPTY_GLOBAL),\n/* harmony export */   REGEX_ENDING: () => (/* binding */ REGEX_ENDING),\n/* harmony export */   REGEX_ENDING_GLOBAL: () => (/* binding */ REGEX_ENDING_GLOBAL),\n/* harmony export */   REGEX_GLOBAL: () => (/* binding */ REGEX_GLOBAL),\n/* harmony export */   REGEX_STARTING: () => (/* binding */ REGEX_STARTING),\n/* harmony export */   REGEX_STARTING_GLOBAL: () => (/* binding */ REGEX_STARTING_GLOBAL),\n/* harmony export */   clsx: () => (/* binding */ clsx),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! unist-util-visit */ \"(ssr)/./node_modules/unist-util-visit-parents/lib/index.js\");\n/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! unist-util-visit */ \"(ssr)/./node_modules/unist-util-visit/lib/index.js\");\n/* harmony import */ var unist_util_find_between_all__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! unist-util-find-between-all */ \"(ssr)/./node_modules/unist-util-find-between-all/dist/lib/index.js\");\n/* harmony import */ var unist_util_find_all_before__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! unist-util-find-all-before */ \"(ssr)/./node_modules/unist-util-find-all-before/lib/index.js\");\n/* harmony import */ var unist_util_find_all_after__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! unist-util-find-all-after */ \"(ssr)/./node_modules/unist-util-find-all-after/lib/index.js\");\n/* harmony import */ var unist_util_find_after__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! unist-util-find-after */ \"(ssr)/./node_modules/unist-util-find-after/lib/index.js\");\n/* harmony import */ var unist_builder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-builder */ \"(ssr)/./node_modules/unist-builder/lib/index.js\");\n\n\n\n\n\n\nconst dictionary = {\n    a: \"amber\",\n    b: \"blue\",\n    c: \"cyan\",\n    d: \"brown\",\n    e: \"espresso\",\n    f: \"fuchsia\",\n    g: \"green\",\n    h: \"hotpink\",\n    i: \"indigo\",\n    j: \"jade\",\n    k: \"kiwi\",\n    l: \"lime\",\n    m: \"magenta\",\n    n: \"navyblue\",\n    o: \"orange\",\n    p: \"purple\",\n    q: \"pink\",\n    r: \"red\",\n    s: \"silver\",\n    t: \"teal\",\n    u: \"umber\",\n    v: \"violet\",\n    w: \"white\",\n    x: \"gray\",\n    y: \"yellow\",\n    z: \"black\",\n};\nconst DEFAULT_SETTINGS = {\n    dictionary,\n    markerTagName: \"mark\",\n    markerClassName: \"flexible-marker\",\n    actionForEmptyContent: \"mark\",\n};\n// the previous regex was not strict related with spaces\n// export const REGEX = /=([a-z]?)=\\s*([^=]*[^ ])?\\s*==/;\n// export const REGEX_GLOBAL = /=([a-z]?)=\\s*([^=]*[^ ])?\\s*==/g;\n// the new regex is strict!\n// it doesn't allow a space after the first double equity sign\n// it doesn't allow a space before the last double equity sign\nconst REGEX = /=([a-z]?)=(?![\\s=])([\\s\\S]*?)(?<![\\s=])==/;\nconst REGEX_GLOBAL = /=([a-z]?)=(?![\\s=])([\\s\\S]*?)(?<![\\s=])==/g;\nconst REGEX_STARTING = /=([a-z]?)=(?![\\s]|=+\\s)/;\nconst REGEX_STARTING_GLOBAL = /=([a-z]?)=(?![\\s]|=+\\s)/g;\nconst REGEX_ENDING = /(?<!\\s|\\s=|\\s==|\\s===|\\s====)==/;\nconst REGEX_ENDING_GLOBAL = /(?<!\\s|\\s=|\\s==|\\s===|\\s====)==/g;\nconst REGEX_EMPTY = /=([a-z]?)=\\s*==/;\nconst REGEX_EMPTY_GLOBAL = /=([a-z]?)=\\s*==/g;\n/**\n *\n * a utility like \"clsx\" package\n */\nfunction clsx(arr) {\n    return arr.filter((item) => !!item);\n}\n/**\n *\n * This plugin turns ==content== into a <mark> element with customizable classification\n *\n * for example:\n *\n * Here is ==marked text with default color==\n * Here is =r=marked text with red classification==\n *\n */\nconst plugin = (options) => {\n    const settings = Object.assign({}, DEFAULT_SETTINGS, options);\n    if (options?.dictionary && Object.keys(options.dictionary).length) {\n        settings.dictionary = Object.assign({}, dictionary, options.dictionary);\n    }\n    /**\n     *\n     * constracts the custom Mark node as a MDAST node\n     *\n     */\n    const constructMarkNode = (classification, children) => {\n        const color = classification ? settings.dictionary[classification] : undefined;\n        const markerTagName = typeof settings.markerTagName === \"string\"\n            ? settings.markerTagName\n            : settings.markerTagName(color);\n        const markerClassName = typeof settings.markerClassName === \"function\"\n            ? settings.markerClassName(color)\n            : clsx([\n                settings.markerClassName,\n                !classification && `${settings.markerClassName}-default`,\n                color && `${settings.markerClassName}-${color}`,\n                !children.length && `${settings.markerClassName}-empty`,\n            ]);\n        let properties;\n        if (settings.markerProperties) {\n            properties = settings.markerProperties(color);\n            Object.entries(properties).forEach(([k, v]) => {\n                if ((typeof v === \"string\" && v === \"\") ||\n                    (Array.isArray(v) && v.length === 0)) {\n                    if (properties) {\n                        properties[k] = undefined;\n                    }\n                }\n                if (k === \"className\")\n                    delete properties?.[\"className\"];\n            });\n        }\n        // https://github.com/syntax-tree/mdast-util-to-hast#example-supporting-custom-nodes\n        return {\n            type: \"mark\",\n            children,\n            data: {\n                hName: markerTagName,\n                hProperties: {\n                    className: markerClassName,\n                    ...(properties && { ...properties }),\n                },\n            },\n        };\n    };\n    /**\n     *\n     * visits the Text nodes to match with the mark syntax (==marked text content==)\n     *\n     */\n    const visitorFirst = function (node, index, parent) {\n        /* v8 ignore next */\n        if (!parent || typeof index === \"undefined\")\n            return;\n        if (!REGEX.test(node.value))\n            return;\n        const children = [];\n        const value = node.value;\n        let tempValue = \"\";\n        let prevMatchIndex = 0;\n        let prevMatchLength = 0;\n        const matches = Array.from(value.matchAll(REGEX_GLOBAL));\n        for (let index = 0; index < matches.length; index++) {\n            const match = matches[index];\n            const [matched, classification, markedText] = match;\n            const mIndex = match.index;\n            const mLength = matched.length;\n            // could be a text part before each matched part\n            const textPartIndex = prevMatchIndex + prevMatchLength;\n            prevMatchIndex = mIndex;\n            prevMatchLength = mLength;\n            // if there is a text part before\n            if (mIndex > textPartIndex) {\n                const textValue = value.substring(textPartIndex, mIndex);\n                const textNode = (0,unist_builder__WEBPACK_IMPORTED_MODULE_0__.u)(\"text\", textValue);\n                children.push(textNode);\n            }\n            const markerNode = constructMarkNode(classification, [\n                { type: \"text\", value: markedText.trim() },\n            ]);\n            children.push(markerNode);\n            // control for the last text node if exists after the last match\n            tempValue = value.slice(mIndex + mLength);\n        }\n        // if there is still text after the last match\n        if (tempValue) {\n            const textNode = (0,unist_builder__WEBPACK_IMPORTED_MODULE_0__.u)(\"text\", tempValue);\n            children.push(textNode);\n        }\n        if (children.length)\n            parent.children.splice(index, 1, ...children);\n    };\n    /**\n     *\n     * visits the Text nodes to find the mark syntax (==marked **text** content==)\n     * if parent contains other content phrases\n     *\n     */\n    const visitorSecond = function (node, index, parent) {\n        /* v8 ignore next */\n        if (!parent || typeof index === \"undefined\")\n            return;\n        // control if the Text node matches with \"starting mark regex\"\n        if (!REGEX_STARTING.test(node.value))\n            return;\n        const openingNode = node;\n        // control if any next child Text node of the parent has \"ending mark regex\"\n        const closingNode = (0,unist_util_find_after__WEBPACK_IMPORTED_MODULE_1__.findAfter)(parent, openingNode, function (node) {\n            return node.type === \"text\" && REGEX_ENDING.test(node.value);\n        });\n        if (!closingNode)\n            return;\n        // now, ensured that the parent has a mark element between opening Text node and closing Text nodes\n        const beforeChildren = (0,unist_util_find_all_before__WEBPACK_IMPORTED_MODULE_2__.findAllBefore)(parent, openingNode);\n        const markChildren = (0,unist_util_find_between_all__WEBPACK_IMPORTED_MODULE_3__.findAllBetween)(parent, openingNode, closingNode);\n        const afterChildren = (0,unist_util_find_all_after__WEBPACK_IMPORTED_MODULE_4__.findAllAfter)(parent, closingNode);\n        /********************* OPENING NODE ***********************/\n        // let's analyze the opening Text node\n        const value = openingNode.value;\n        const match = Array.from(value.matchAll(REGEX_STARTING_GLOBAL))[0];\n        const [matched, classification] = match;\n        const mLength = matched.length;\n        const mIndex = match.index;\n        // if there is a text part before\n        if (mIndex > 0) {\n            const textValue = value.substring(0, mIndex);\n            const textNode = (0,unist_builder__WEBPACK_IMPORTED_MODULE_0__.u)(\"text\", textValue);\n            beforeChildren.push(textNode);\n        }\n        // if there is a text part after\n        if (value.length > mIndex + mLength) {\n            const textValue = value.slice(mIndex + mLength);\n            const textNode = (0,unist_builder__WEBPACK_IMPORTED_MODULE_0__.u)(\"text\", textValue);\n            markChildren.unshift(textNode);\n        }\n        /********************* CLOSING NODE ***********************/\n        // let's analyze the closing Text node\n        const value_ = closingNode.value;\n        const match_ = Array.from(value_.matchAll(REGEX_ENDING_GLOBAL))[0];\n        const [matched_] = match_;\n        const mLength_ = matched_.length;\n        const mIndex_ = match_.index;\n        // if there is a text part before\n        if (mIndex_ > 0) {\n            const textValue = value_.substring(0, mIndex_);\n            const textNode = (0,unist_builder__WEBPACK_IMPORTED_MODULE_0__.u)(\"text\", textValue);\n            markChildren.push(textNode);\n        }\n        // if there is a text part after\n        if (value_.length > mIndex_ + mLength_) {\n            const textValue = value_.slice(mIndex_ + mLength_);\n            const textNode = (0,unist_builder__WEBPACK_IMPORTED_MODULE_0__.u)(\"text\", textValue);\n            afterChildren.unshift(textNode);\n        }\n        // now it is time to construct a mark node\n        const markNode = constructMarkNode(classification, markChildren);\n        parent.children = [...beforeChildren, markNode, ...afterChildren];\n        return index; // in order to re-visit the same node and children\n    };\n    /**\n     *\n     * visits the Text nodes to find empty markers (==== or == ==)\n     *\n     */\n    const visitorThird = function (node, index, parent) {\n        /* v8 ignore next */\n        if (!parent || typeof index === \"undefined\")\n            return;\n        if (!REGEX_EMPTY.test(node.value))\n            return;\n        if (settings.actionForEmptyContent === \"remove\") {\n            node.value = node.value.replaceAll(REGEX_EMPTY_GLOBAL, \"\");\n            // https://unifiedjs.com/learn/recipe/remove-node/\n            if (node.value.trim() === \"\")\n                return [unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.SKIP, index];\n            return unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.CONTINUE;\n        }\n        const children = [];\n        const value = node.value;\n        let tempValue = \"\";\n        let prevMatchIndex = 0;\n        let prevMatchLength = 0;\n        const matches = Array.from(value.matchAll(REGEX_EMPTY_GLOBAL));\n        for (let index = 0; index < matches.length; index++) {\n            const match = matches[index];\n            const [matched, classification] = match;\n            const mIndex = match.index;\n            const mLength = matched.length;\n            // could be a text part before each matched part\n            const textPartIndex = prevMatchIndex + prevMatchLength;\n            prevMatchIndex = mIndex;\n            prevMatchLength = mLength;\n            // if there is a text part before\n            if (mIndex > textPartIndex) {\n                const textValue = value.substring(textPartIndex, mIndex);\n                const textNode = (0,unist_builder__WEBPACK_IMPORTED_MODULE_0__.u)(\"text\", textValue);\n                children.push(textNode);\n            }\n            // empty marker\n            const markerNode = constructMarkNode(classification, []);\n            children.push(markerNode);\n            // control for the last text node if exists after the last match\n            tempValue = value.slice(mIndex + mLength);\n        }\n        // if there is still text after the last match\n        if (tempValue) {\n            const textNode = (0,unist_builder__WEBPACK_IMPORTED_MODULE_0__.u)(\"text\", tempValue);\n            children.push(textNode);\n        }\n        if (children.length)\n            parent.children.splice(index, 1, ...children);\n    };\n    const transformer = (tree) => {\n        // to find markers in a Text node\n        (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_6__.visit)(tree, \"text\", visitorFirst);\n        // to find markers if the parent contains other content phrases\n        (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_6__.visit)(tree, \"text\", visitorSecond);\n        // to find empty markers (==== or == ==)\n        if (settings.actionForEmptyContent !== \"keep\") {\n            (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_6__.visit)(tree, \"text\", visitorThird);\n        }\n        // to correct the mathematical double equity signs\n        if (settings.equalityOperator) {\n            const REGEX_EQUALITY = new RegExp(settings.equalityOperator, \"gi\");\n            (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_6__.visit)(tree, \"text\", (node) => {\n                node.value = node.value.replaceAll(REGEX_EQUALITY, \"==\");\n            });\n        }\n    };\n    return transformer;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVtYXJrLWZsZXhpYmxlLW1hcmtlcnMvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBeUQ7QUFDSTtBQUNGO0FBQ0Y7QUFDUDtBQUNoQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHlCQUF5QjtBQUMvRCw0QkFBNEIseUJBQXlCLEdBQUcsTUFBTTtBQUM5RCx1Q0FBdUMseUJBQXlCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxlQUFlO0FBQ3ZELGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0RBQUM7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdDQUF3QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnREFBQztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdFQUFTO0FBQ3JDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5RUFBYTtBQUM1Qyw2QkFBNkIsMkVBQWM7QUFDM0MsOEJBQThCLHVFQUFZO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdEQUFDO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0RBQUM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdEQUFDO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0RBQUM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrREFBSTtBQUM1QixtQkFBbUIsc0RBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0RBQUM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0RBQUM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFLO0FBQ2I7QUFDQSxRQUFRLHVEQUFLO0FBQ2I7QUFDQTtBQUNBLFlBQVksdURBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVEQUFLO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsTUFBTSxFQUFDO0FBQ3RCIiwic291cmNlcyI6WyIvVXNlcnMva3J6eXN6dG9ma29jb3QvRGVza3RvcC9sYW5kaW5nLXBhZ2Uvbm9kZV9tb2R1bGVzL3JlbWFyay1mbGV4aWJsZS1tYXJrZXJzL2Rpc3QvZXNtL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENPTlRJTlVFLCBTS0lQLCB2aXNpdCB9IGZyb20gXCJ1bmlzdC11dGlsLXZpc2l0XCI7XG5pbXBvcnQgeyBmaW5kQWxsQmV0d2VlbiB9IGZyb20gXCJ1bmlzdC11dGlsLWZpbmQtYmV0d2Vlbi1hbGxcIjtcbmltcG9ydCB7IGZpbmRBbGxCZWZvcmUgfSBmcm9tIFwidW5pc3QtdXRpbC1maW5kLWFsbC1iZWZvcmVcIjtcbmltcG9ydCB7IGZpbmRBbGxBZnRlciB9IGZyb20gXCJ1bmlzdC11dGlsLWZpbmQtYWxsLWFmdGVyXCI7XG5pbXBvcnQgeyBmaW5kQWZ0ZXIgfSBmcm9tIFwidW5pc3QtdXRpbC1maW5kLWFmdGVyXCI7XG5pbXBvcnQgeyB1IH0gZnJvbSBcInVuaXN0LWJ1aWxkZXJcIjtcbmNvbnN0IGRpY3Rpb25hcnkgPSB7XG4gICAgYTogXCJhbWJlclwiLFxuICAgIGI6IFwiYmx1ZVwiLFxuICAgIGM6IFwiY3lhblwiLFxuICAgIGQ6IFwiYnJvd25cIixcbiAgICBlOiBcImVzcHJlc3NvXCIsXG4gICAgZjogXCJmdWNoc2lhXCIsXG4gICAgZzogXCJncmVlblwiLFxuICAgIGg6IFwiaG90cGlua1wiLFxuICAgIGk6IFwiaW5kaWdvXCIsXG4gICAgajogXCJqYWRlXCIsXG4gICAgazogXCJraXdpXCIsXG4gICAgbDogXCJsaW1lXCIsXG4gICAgbTogXCJtYWdlbnRhXCIsXG4gICAgbjogXCJuYXZ5Ymx1ZVwiLFxuICAgIG86IFwib3JhbmdlXCIsXG4gICAgcDogXCJwdXJwbGVcIixcbiAgICBxOiBcInBpbmtcIixcbiAgICByOiBcInJlZFwiLFxuICAgIHM6IFwic2lsdmVyXCIsXG4gICAgdDogXCJ0ZWFsXCIsXG4gICAgdTogXCJ1bWJlclwiLFxuICAgIHY6IFwidmlvbGV0XCIsXG4gICAgdzogXCJ3aGl0ZVwiLFxuICAgIHg6IFwiZ3JheVwiLFxuICAgIHk6IFwieWVsbG93XCIsXG4gICAgejogXCJibGFja1wiLFxufTtcbmNvbnN0IERFRkFVTFRfU0VUVElOR1MgPSB7XG4gICAgZGljdGlvbmFyeSxcbiAgICBtYXJrZXJUYWdOYW1lOiBcIm1hcmtcIixcbiAgICBtYXJrZXJDbGFzc05hbWU6IFwiZmxleGlibGUtbWFya2VyXCIsXG4gICAgYWN0aW9uRm9yRW1wdHlDb250ZW50OiBcIm1hcmtcIixcbn07XG4vLyB0aGUgcHJldmlvdXMgcmVnZXggd2FzIG5vdCBzdHJpY3QgcmVsYXRlZCB3aXRoIHNwYWNlc1xuLy8gZXhwb3J0IGNvbnN0IFJFR0VYID0gLz0oW2Etel0/KT1cXHMqKFtePV0qW14gXSk/XFxzKj09Lztcbi8vIGV4cG9ydCBjb25zdCBSRUdFWF9HTE9CQUwgPSAvPShbYS16XT8pPVxccyooW149XSpbXiBdKT9cXHMqPT0vZztcbi8vIHRoZSBuZXcgcmVnZXggaXMgc3RyaWN0IVxuLy8gaXQgZG9lc24ndCBhbGxvdyBhIHNwYWNlIGFmdGVyIHRoZSBmaXJzdCBkb3VibGUgZXF1aXR5IHNpZ25cbi8vIGl0IGRvZXNuJ3QgYWxsb3cgYSBzcGFjZSBiZWZvcmUgdGhlIGxhc3QgZG91YmxlIGVxdWl0eSBzaWduXG5leHBvcnQgY29uc3QgUkVHRVggPSAvPShbYS16XT8pPSg/IVtcXHM9XSkoW1xcc1xcU10qPykoPzwhW1xccz1dKT09LztcbmV4cG9ydCBjb25zdCBSRUdFWF9HTE9CQUwgPSAvPShbYS16XT8pPSg/IVtcXHM9XSkoW1xcc1xcU10qPykoPzwhW1xccz1dKT09L2c7XG5leHBvcnQgY29uc3QgUkVHRVhfU1RBUlRJTkcgPSAvPShbYS16XT8pPSg/IVtcXHNdfD0rXFxzKS87XG5leHBvcnQgY29uc3QgUkVHRVhfU1RBUlRJTkdfR0xPQkFMID0gLz0oW2Etel0/KT0oPyFbXFxzXXw9K1xccykvZztcbmV4cG9ydCBjb25zdCBSRUdFWF9FTkRJTkcgPSAvKD88IVxcc3xcXHM9fFxccz09fFxccz09PXxcXHM9PT09KT09LztcbmV4cG9ydCBjb25zdCBSRUdFWF9FTkRJTkdfR0xPQkFMID0gLyg/PCFcXHN8XFxzPXxcXHM9PXxcXHM9PT18XFxzPT09PSk9PS9nO1xuZXhwb3J0IGNvbnN0IFJFR0VYX0VNUFRZID0gLz0oW2Etel0/KT1cXHMqPT0vO1xuZXhwb3J0IGNvbnN0IFJFR0VYX0VNUFRZX0dMT0JBTCA9IC89KFthLXpdPyk9XFxzKj09L2c7XG4vKipcbiAqXG4gKiBhIHV0aWxpdHkgbGlrZSBcImNsc3hcIiBwYWNrYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbHN4KGFycikge1xuICAgIHJldHVybiBhcnIuZmlsdGVyKChpdGVtKSA9PiAhIWl0ZW0pO1xufVxuLyoqXG4gKlxuICogVGhpcyBwbHVnaW4gdHVybnMgPT1jb250ZW50PT0gaW50byBhIDxtYXJrPiBlbGVtZW50IHdpdGggY3VzdG9taXphYmxlIGNsYXNzaWZpY2F0aW9uXG4gKlxuICogZm9yIGV4YW1wbGU6XG4gKlxuICogSGVyZSBpcyA9PW1hcmtlZCB0ZXh0IHdpdGggZGVmYXVsdCBjb2xvcj09XG4gKiBIZXJlIGlzID1yPW1hcmtlZCB0ZXh0IHdpdGggcmVkIGNsYXNzaWZpY2F0aW9uPT1cbiAqXG4gKi9cbmNvbnN0IHBsdWdpbiA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucz8uZGljdGlvbmFyeSAmJiBPYmplY3Qua2V5cyhvcHRpb25zLmRpY3Rpb25hcnkpLmxlbmd0aCkge1xuICAgICAgICBzZXR0aW5ncy5kaWN0aW9uYXJ5ID0gT2JqZWN0LmFzc2lnbih7fSwgZGljdGlvbmFyeSwgb3B0aW9ucy5kaWN0aW9uYXJ5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBjb25zdHJhY3RzIHRoZSBjdXN0b20gTWFyayBub2RlIGFzIGEgTURBU1Qgbm9kZVxuICAgICAqXG4gICAgICovXG4gICAgY29uc3QgY29uc3RydWN0TWFya05vZGUgPSAoY2xhc3NpZmljYXRpb24sIGNoaWxkcmVuKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gY2xhc3NpZmljYXRpb24gPyBzZXR0aW5ncy5kaWN0aW9uYXJ5W2NsYXNzaWZpY2F0aW9uXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgbWFya2VyVGFnTmFtZSA9IHR5cGVvZiBzZXR0aW5ncy5tYXJrZXJUYWdOYW1lID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IHNldHRpbmdzLm1hcmtlclRhZ05hbWVcbiAgICAgICAgICAgIDogc2V0dGluZ3MubWFya2VyVGFnTmFtZShjb2xvcik7XG4gICAgICAgIGNvbnN0IG1hcmtlckNsYXNzTmFtZSA9IHR5cGVvZiBzZXR0aW5ncy5tYXJrZXJDbGFzc05hbWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyBzZXR0aW5ncy5tYXJrZXJDbGFzc05hbWUoY29sb3IpXG4gICAgICAgICAgICA6IGNsc3goW1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLm1hcmtlckNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICAhY2xhc3NpZmljYXRpb24gJiYgYCR7c2V0dGluZ3MubWFya2VyQ2xhc3NOYW1lfS1kZWZhdWx0YCxcbiAgICAgICAgICAgICAgICBjb2xvciAmJiBgJHtzZXR0aW5ncy5tYXJrZXJDbGFzc05hbWV9LSR7Y29sb3J9YCxcbiAgICAgICAgICAgICAgICAhY2hpbGRyZW4ubGVuZ3RoICYmIGAke3NldHRpbmdzLm1hcmtlckNsYXNzTmFtZX0tZW1wdHlgLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIGxldCBwcm9wZXJ0aWVzO1xuICAgICAgICBpZiAoc2V0dGluZ3MubWFya2VyUHJvcGVydGllcykge1xuICAgICAgICAgICAgcHJvcGVydGllcyA9IHNldHRpbmdzLm1hcmtlclByb3BlcnRpZXMoY29sb3IpO1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMocHJvcGVydGllcykuZm9yRWFjaCgoW2ssIHZdKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIiAmJiB2ID09PSBcIlwiKSB8fFxuICAgICAgICAgICAgICAgICAgICAoQXJyYXkuaXNBcnJheSh2KSAmJiB2Lmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXNba10gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGsgPT09IFwiY2xhc3NOYW1lXCIpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwcm9wZXJ0aWVzPy5bXCJjbGFzc05hbWVcIl07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc3ludGF4LXRyZWUvbWRhc3QtdXRpbC10by1oYXN0I2V4YW1wbGUtc3VwcG9ydGluZy1jdXN0b20tbm9kZXNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwibWFya1wiLFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgaE5hbWU6IG1hcmtlclRhZ05hbWUsXG4gICAgICAgICAgICAgICAgaFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBtYXJrZXJDbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgICAgIC4uLihwcm9wZXJ0aWVzICYmIHsgLi4ucHJvcGVydGllcyB9KSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogdmlzaXRzIHRoZSBUZXh0IG5vZGVzIHRvIG1hdGNoIHdpdGggdGhlIG1hcmsgc3ludGF4ICg9PW1hcmtlZCB0ZXh0IGNvbnRlbnQ9PSlcbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0IHZpc2l0b3JGaXJzdCA9IGZ1bmN0aW9uIChub2RlLCBpbmRleCwgcGFyZW50KSB7XG4gICAgICAgIC8qIHY4IGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmICghcGFyZW50IHx8IHR5cGVvZiBpbmRleCA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFSRUdFWC50ZXN0KG5vZGUudmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgICAgIGxldCB0ZW1wVmFsdWUgPSBcIlwiO1xuICAgICAgICBsZXQgcHJldk1hdGNoSW5kZXggPSAwO1xuICAgICAgICBsZXQgcHJldk1hdGNoTGVuZ3RoID0gMDtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IEFycmF5LmZyb20odmFsdWUubWF0Y2hBbGwoUkVHRVhfR0xPQkFMKSk7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBtYXRjaGVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBtYXRjaGVzW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IFttYXRjaGVkLCBjbGFzc2lmaWNhdGlvbiwgbWFya2VkVGV4dF0gPSBtYXRjaDtcbiAgICAgICAgICAgIGNvbnN0IG1JbmRleCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgICAgY29uc3QgbUxlbmd0aCA9IG1hdGNoZWQubGVuZ3RoO1xuICAgICAgICAgICAgLy8gY291bGQgYmUgYSB0ZXh0IHBhcnQgYmVmb3JlIGVhY2ggbWF0Y2hlZCBwYXJ0XG4gICAgICAgICAgICBjb25zdCB0ZXh0UGFydEluZGV4ID0gcHJldk1hdGNoSW5kZXggKyBwcmV2TWF0Y2hMZW5ndGg7XG4gICAgICAgICAgICBwcmV2TWF0Y2hJbmRleCA9IG1JbmRleDtcbiAgICAgICAgICAgIHByZXZNYXRjaExlbmd0aCA9IG1MZW5ndGg7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHRleHQgcGFydCBiZWZvcmVcbiAgICAgICAgICAgIGlmIChtSW5kZXggPiB0ZXh0UGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dFZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKHRleHRQYXJ0SW5kZXgsIG1JbmRleCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dE5vZGUgPSB1KFwidGV4dFwiLCB0ZXh0VmFsdWUpO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGV4dE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWFya2VyTm9kZSA9IGNvbnN0cnVjdE1hcmtOb2RlKGNsYXNzaWZpY2F0aW9uLCBbXG4gICAgICAgICAgICAgICAgeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IG1hcmtlZFRleHQudHJpbSgpIH0sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobWFya2VyTm9kZSk7XG4gICAgICAgICAgICAvLyBjb250cm9sIGZvciB0aGUgbGFzdCB0ZXh0IG5vZGUgaWYgZXhpc3RzIGFmdGVyIHRoZSBsYXN0IG1hdGNoXG4gICAgICAgICAgICB0ZW1wVmFsdWUgPSB2YWx1ZS5zbGljZShtSW5kZXggKyBtTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBzdGlsbCB0ZXh0IGFmdGVyIHRoZSBsYXN0IG1hdGNoXG4gICAgICAgIGlmICh0ZW1wVmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gdShcInRleHRcIiwgdGVtcFZhbHVlKTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGV4dE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxLCAuLi5jaGlsZHJlbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIHZpc2l0cyB0aGUgVGV4dCBub2RlcyB0byBmaW5kIHRoZSBtYXJrIHN5bnRheCAoPT1tYXJrZWQgKip0ZXh0KiogY29udGVudD09KVxuICAgICAqIGlmIHBhcmVudCBjb250YWlucyBvdGhlciBjb250ZW50IHBocmFzZXNcbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0IHZpc2l0b3JTZWNvbmQgPSBmdW5jdGlvbiAobm9kZSwgaW5kZXgsIHBhcmVudCkge1xuICAgICAgICAvKiB2OCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpZiAoIXBhcmVudCB8fCB0eXBlb2YgaW5kZXggPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIGNvbnRyb2wgaWYgdGhlIFRleHQgbm9kZSBtYXRjaGVzIHdpdGggXCJzdGFydGluZyBtYXJrIHJlZ2V4XCJcbiAgICAgICAgaWYgKCFSRUdFWF9TVEFSVElORy50ZXN0KG5vZGUudmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBvcGVuaW5nTm9kZSA9IG5vZGU7XG4gICAgICAgIC8vIGNvbnRyb2wgaWYgYW55IG5leHQgY2hpbGQgVGV4dCBub2RlIG9mIHRoZSBwYXJlbnQgaGFzIFwiZW5kaW5nIG1hcmsgcmVnZXhcIlxuICAgICAgICBjb25zdCBjbG9zaW5nTm9kZSA9IGZpbmRBZnRlcihwYXJlbnQsIG9wZW5pbmdOb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJ0ZXh0XCIgJiYgUkVHRVhfRU5ESU5HLnRlc3Qobm9kZS52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNsb3NpbmdOb2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBub3csIGVuc3VyZWQgdGhhdCB0aGUgcGFyZW50IGhhcyBhIG1hcmsgZWxlbWVudCBiZXR3ZWVuIG9wZW5pbmcgVGV4dCBub2RlIGFuZCBjbG9zaW5nIFRleHQgbm9kZXNcbiAgICAgICAgY29uc3QgYmVmb3JlQ2hpbGRyZW4gPSBmaW5kQWxsQmVmb3JlKHBhcmVudCwgb3BlbmluZ05vZGUpO1xuICAgICAgICBjb25zdCBtYXJrQ2hpbGRyZW4gPSBmaW5kQWxsQmV0d2VlbihwYXJlbnQsIG9wZW5pbmdOb2RlLCBjbG9zaW5nTm9kZSk7XG4gICAgICAgIGNvbnN0IGFmdGVyQ2hpbGRyZW4gPSBmaW5kQWxsQWZ0ZXIocGFyZW50LCBjbG9zaW5nTm9kZSk7XG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKiogT1BFTklORyBOT0RFICoqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvLyBsZXQncyBhbmFseXplIHRoZSBvcGVuaW5nIFRleHQgbm9kZVxuICAgICAgICBjb25zdCB2YWx1ZSA9IG9wZW5pbmdOb2RlLnZhbHVlO1xuICAgICAgICBjb25zdCBtYXRjaCA9IEFycmF5LmZyb20odmFsdWUubWF0Y2hBbGwoUkVHRVhfU1RBUlRJTkdfR0xPQkFMKSlbMF07XG4gICAgICAgIGNvbnN0IFttYXRjaGVkLCBjbGFzc2lmaWNhdGlvbl0gPSBtYXRjaDtcbiAgICAgICAgY29uc3QgbUxlbmd0aCA9IG1hdGNoZWQubGVuZ3RoO1xuICAgICAgICBjb25zdCBtSW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSB0ZXh0IHBhcnQgYmVmb3JlXG4gICAgICAgIGlmIChtSW5kZXggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0VmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgbUluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gdShcInRleHRcIiwgdGV4dFZhbHVlKTtcbiAgICAgICAgICAgIGJlZm9yZUNoaWxkcmVuLnB1c2godGV4dE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgdGV4dCBwYXJ0IGFmdGVyXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiBtSW5kZXggKyBtTGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0VmFsdWUgPSB2YWx1ZS5zbGljZShtSW5kZXggKyBtTGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gdShcInRleHRcIiwgdGV4dFZhbHVlKTtcbiAgICAgICAgICAgIG1hcmtDaGlsZHJlbi51bnNoaWZ0KHRleHROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqIENMT1NJTkcgTk9ERSAqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLy8gbGV0J3MgYW5hbHl6ZSB0aGUgY2xvc2luZyBUZXh0IG5vZGVcbiAgICAgICAgY29uc3QgdmFsdWVfID0gY2xvc2luZ05vZGUudmFsdWU7XG4gICAgICAgIGNvbnN0IG1hdGNoXyA9IEFycmF5LmZyb20odmFsdWVfLm1hdGNoQWxsKFJFR0VYX0VORElOR19HTE9CQUwpKVswXTtcbiAgICAgICAgY29uc3QgW21hdGNoZWRfXSA9IG1hdGNoXztcbiAgICAgICAgY29uc3QgbUxlbmd0aF8gPSBtYXRjaGVkXy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG1JbmRleF8gPSBtYXRjaF8uaW5kZXg7XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgdGV4dCBwYXJ0IGJlZm9yZVxuICAgICAgICBpZiAobUluZGV4XyA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHRWYWx1ZSA9IHZhbHVlXy5zdWJzdHJpbmcoMCwgbUluZGV4Xyk7XG4gICAgICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9IHUoXCJ0ZXh0XCIsIHRleHRWYWx1ZSk7XG4gICAgICAgICAgICBtYXJrQ2hpbGRyZW4ucHVzaCh0ZXh0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSB0ZXh0IHBhcnQgYWZ0ZXJcbiAgICAgICAgaWYgKHZhbHVlXy5sZW5ndGggPiBtSW5kZXhfICsgbUxlbmd0aF8pIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHRWYWx1ZSA9IHZhbHVlXy5zbGljZShtSW5kZXhfICsgbUxlbmd0aF8pO1xuICAgICAgICAgICAgY29uc3QgdGV4dE5vZGUgPSB1KFwidGV4dFwiLCB0ZXh0VmFsdWUpO1xuICAgICAgICAgICAgYWZ0ZXJDaGlsZHJlbi51bnNoaWZ0KHRleHROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3cgaXQgaXMgdGltZSB0byBjb25zdHJ1Y3QgYSBtYXJrIG5vZGVcbiAgICAgICAgY29uc3QgbWFya05vZGUgPSBjb25zdHJ1Y3RNYXJrTm9kZShjbGFzc2lmaWNhdGlvbiwgbWFya0NoaWxkcmVuKTtcbiAgICAgICAgcGFyZW50LmNoaWxkcmVuID0gWy4uLmJlZm9yZUNoaWxkcmVuLCBtYXJrTm9kZSwgLi4uYWZ0ZXJDaGlsZHJlbl07XG4gICAgICAgIHJldHVybiBpbmRleDsgLy8gaW4gb3JkZXIgdG8gcmUtdmlzaXQgdGhlIHNhbWUgbm9kZSBhbmQgY2hpbGRyZW5cbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogdmlzaXRzIHRoZSBUZXh0IG5vZGVzIHRvIGZpbmQgZW1wdHkgbWFya2VycyAoPT09PSBvciA9PSA9PSlcbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0IHZpc2l0b3JUaGlyZCA9IGZ1bmN0aW9uIChub2RlLCBpbmRleCwgcGFyZW50KSB7XG4gICAgICAgIC8qIHY4IGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmICghcGFyZW50IHx8IHR5cGVvZiBpbmRleCA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFSRUdFWF9FTVBUWS50ZXN0KG5vZGUudmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoc2V0dGluZ3MuYWN0aW9uRm9yRW1wdHlDb250ZW50ID09PSBcInJlbW92ZVwiKSB7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gbm9kZS52YWx1ZS5yZXBsYWNlQWxsKFJFR0VYX0VNUFRZX0dMT0JBTCwgXCJcIik7XG4gICAgICAgICAgICAvLyBodHRwczovL3VuaWZpZWRqcy5jb20vbGVhcm4vcmVjaXBlL3JlbW92ZS1ub2RlL1xuICAgICAgICAgICAgaWYgKG5vZGUudmFsdWUudHJpbSgpID09PSBcIlwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBbU0tJUCwgaW5kZXhdO1xuICAgICAgICAgICAgcmV0dXJuIENPTlRJTlVFO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gW107XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICAgICAgbGV0IHRlbXBWYWx1ZSA9IFwiXCI7XG4gICAgICAgIGxldCBwcmV2TWF0Y2hJbmRleCA9IDA7XG4gICAgICAgIGxldCBwcmV2TWF0Y2hMZW5ndGggPSAwO1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gQXJyYXkuZnJvbSh2YWx1ZS5tYXRjaEFsbChSRUdFWF9FTVBUWV9HTE9CQUwpKTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG1hdGNoZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IG1hdGNoZXNbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgW21hdGNoZWQsIGNsYXNzaWZpY2F0aW9uXSA9IG1hdGNoO1xuICAgICAgICAgICAgY29uc3QgbUluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgICBjb25zdCBtTGVuZ3RoID0gbWF0Y2hlZC5sZW5ndGg7XG4gICAgICAgICAgICAvLyBjb3VsZCBiZSBhIHRleHQgcGFydCBiZWZvcmUgZWFjaCBtYXRjaGVkIHBhcnRcbiAgICAgICAgICAgIGNvbnN0IHRleHRQYXJ0SW5kZXggPSBwcmV2TWF0Y2hJbmRleCArIHByZXZNYXRjaExlbmd0aDtcbiAgICAgICAgICAgIHByZXZNYXRjaEluZGV4ID0gbUluZGV4O1xuICAgICAgICAgICAgcHJldk1hdGNoTGVuZ3RoID0gbUxlbmd0aDtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgdGV4dCBwYXJ0IGJlZm9yZVxuICAgICAgICAgICAgaWYgKG1JbmRleCA+IHRleHRQYXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0VmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcodGV4dFBhcnRJbmRleCwgbUluZGV4KTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9IHUoXCJ0ZXh0XCIsIHRleHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0ZXh0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbXB0eSBtYXJrZXJcbiAgICAgICAgICAgIGNvbnN0IG1hcmtlck5vZGUgPSBjb25zdHJ1Y3RNYXJrTm9kZShjbGFzc2lmaWNhdGlvbiwgW10pO1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChtYXJrZXJOb2RlKTtcbiAgICAgICAgICAgIC8vIGNvbnRyb2wgZm9yIHRoZSBsYXN0IHRleHQgbm9kZSBpZiBleGlzdHMgYWZ0ZXIgdGhlIGxhc3QgbWF0Y2hcbiAgICAgICAgICAgIHRlbXBWYWx1ZSA9IHZhbHVlLnNsaWNlKG1JbmRleCArIG1MZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIHN0aWxsIHRleHQgYWZ0ZXIgdGhlIGxhc3QgbWF0Y2hcbiAgICAgICAgaWYgKHRlbXBWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgdGV4dE5vZGUgPSB1KFwidGV4dFwiLCB0ZW1wVmFsdWUpO1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0ZXh0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEsIC4uLmNoaWxkcmVuKTtcbiAgICB9O1xuICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gKHRyZWUpID0+IHtcbiAgICAgICAgLy8gdG8gZmluZCBtYXJrZXJzIGluIGEgVGV4dCBub2RlXG4gICAgICAgIHZpc2l0KHRyZWUsIFwidGV4dFwiLCB2aXNpdG9yRmlyc3QpO1xuICAgICAgICAvLyB0byBmaW5kIG1hcmtlcnMgaWYgdGhlIHBhcmVudCBjb250YWlucyBvdGhlciBjb250ZW50IHBocmFzZXNcbiAgICAgICAgdmlzaXQodHJlZSwgXCJ0ZXh0XCIsIHZpc2l0b3JTZWNvbmQpO1xuICAgICAgICAvLyB0byBmaW5kIGVtcHR5IG1hcmtlcnMgKD09PT0gb3IgPT0gPT0pXG4gICAgICAgIGlmIChzZXR0aW5ncy5hY3Rpb25Gb3JFbXB0eUNvbnRlbnQgIT09IFwia2VlcFwiKSB7XG4gICAgICAgICAgICB2aXNpdCh0cmVlLCBcInRleHRcIiwgdmlzaXRvclRoaXJkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0byBjb3JyZWN0IHRoZSBtYXRoZW1hdGljYWwgZG91YmxlIGVxdWl0eSBzaWduc1xuICAgICAgICBpZiAoc2V0dGluZ3MuZXF1YWxpdHlPcGVyYXRvcikge1xuICAgICAgICAgICAgY29uc3QgUkVHRVhfRVFVQUxJVFkgPSBuZXcgUmVnRXhwKHNldHRpbmdzLmVxdWFsaXR5T3BlcmF0b3IsIFwiZ2lcIik7XG4gICAgICAgICAgICB2aXNpdCh0cmVlLCBcInRleHRcIiwgKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gbm9kZS52YWx1ZS5yZXBsYWNlQWxsKFJFR0VYX0VRVUFMSVRZLCBcIj09XCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB0cmFuc2Zvcm1lcjtcbn07XG5leHBvcnQgZGVmYXVsdCBwbHVnaW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/remark-flexible-markers/dist/esm/index.js\n");

/***/ })

};
;