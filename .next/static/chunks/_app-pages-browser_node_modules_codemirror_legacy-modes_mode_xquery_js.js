"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_codemirror_legacy-modes_mode_xquery_js"],{

/***/ "(app-pages-browser)/./node_modules/@codemirror/legacy-modes/mode/xquery.js":
/*!**************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/xquery.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   xQuery: () => (/* binding */ xQuery)\n/* harmony export */ });\n// The keywords object is set to the result of this self executing\n// function. Each keyword is a property of the keywords object whose\n// value is {type: atype, style: astyle}\nvar keywords = function(){\n  // convenience functions used to build keywords object\n  function kw(type) {return {type: type, style: \"keyword\"};}\n  var operator = kw(\"operator\")\n  , atom = {type: \"atom\", style: \"atom\"}\n  , punctuation = {type: \"punctuation\", style: null}\n  , qualifier = {type: \"axis_specifier\", style: \"qualifier\"};\n\n  // kwObj is what is return from this function at the end\n  var kwObj = {\n    ',': punctuation\n  };\n\n  // a list of 'basic' keywords. For each add a property to kwObj with the value of\n  // {type: basic[i], style: \"keyword\"} e.g. 'after' --> {type: \"after\", style: \"keyword\"}\n  var basic = ['after', 'all', 'allowing', 'ancestor', 'ancestor-or-self', 'any', 'array', 'as',\n               'ascending', 'at', 'attribute', 'base-uri', 'before', 'boundary-space', 'by', 'case', 'cast',\n               'castable', 'catch', 'child', 'collation', 'comment', 'construction', 'contains', 'content',\n               'context', 'copy', 'copy-namespaces', 'count', 'decimal-format', 'declare', 'default', 'delete',\n               'descendant', 'descendant-or-self', 'descending', 'diacritics', 'different', 'distance',\n               'document', 'document-node', 'element', 'else', 'empty', 'empty-sequence', 'encoding', 'end',\n               'entire', 'every', 'exactly', 'except', 'external', 'first', 'following', 'following-sibling',\n               'for', 'from', 'ftand', 'ftnot', 'ft-option', 'ftor', 'function', 'fuzzy', 'greatest', 'group',\n               'if', 'import', 'in', 'inherit', 'insensitive', 'insert', 'instance', 'intersect', 'into',\n               'invoke', 'is', 'item', 'language', 'last', 'lax', 'least', 'let', 'levels', 'lowercase', 'map',\n               'modify', 'module', 'most', 'namespace', 'next', 'no', 'node', 'nodes', 'no-inherit',\n               'no-preserve', 'not', 'occurs', 'of', 'only', 'option', 'order', 'ordered', 'ordering',\n               'paragraph', 'paragraphs', 'parent', 'phrase', 'preceding', 'preceding-sibling', 'preserve',\n               'previous', 'processing-instruction', 'relationship', 'rename', 'replace', 'return',\n               'revalidation', 'same', 'satisfies', 'schema', 'schema-attribute', 'schema-element', 'score',\n               'self', 'sensitive', 'sentence', 'sentences', 'sequence', 'skip', 'sliding', 'some', 'stable',\n               'start', 'stemming', 'stop', 'strict', 'strip', 'switch', 'text', 'then', 'thesaurus', 'times',\n               'to', 'transform', 'treat', 'try', 'tumbling', 'type', 'typeswitch', 'union', 'unordered',\n               'update', 'updating', 'uppercase', 'using', 'validate', 'value', 'variable', 'version',\n               'weight', 'when', 'where', 'wildcards', 'window', 'with', 'without', 'word', 'words', 'xquery'];\n  for(var i=0, l=basic.length; i < l; i++) { kwObj[basic[i]] = kw(basic[i]);};\n\n  // a list of types. For each add a property to kwObj with the value of\n  // {type: \"atom\", style: \"atom\"}\n  var types = ['xs:anyAtomicType', 'xs:anySimpleType', 'xs:anyType', 'xs:anyURI',\n               'xs:base64Binary', 'xs:boolean', 'xs:byte', 'xs:date', 'xs:dateTime', 'xs:dateTimeStamp',\n               'xs:dayTimeDuration', 'xs:decimal', 'xs:double', 'xs:duration', 'xs:ENTITIES', 'xs:ENTITY',\n               'xs:float', 'xs:gDay', 'xs:gMonth', 'xs:gMonthDay', 'xs:gYear', 'xs:gYearMonth', 'xs:hexBinary',\n               'xs:ID', 'xs:IDREF', 'xs:IDREFS', 'xs:int', 'xs:integer', 'xs:item', 'xs:java', 'xs:language',\n               'xs:long', 'xs:Name', 'xs:NCName', 'xs:negativeInteger', 'xs:NMTOKEN', 'xs:NMTOKENS',\n               'xs:nonNegativeInteger', 'xs:nonPositiveInteger', 'xs:normalizedString', 'xs:NOTATION',\n               'xs:numeric', 'xs:positiveInteger', 'xs:precisionDecimal', 'xs:QName', 'xs:short', 'xs:string',\n               'xs:time', 'xs:token', 'xs:unsignedByte', 'xs:unsignedInt', 'xs:unsignedLong',\n               'xs:unsignedShort', 'xs:untyped', 'xs:untypedAtomic', 'xs:yearMonthDuration'];\n  for(var i=0, l=types.length; i < l; i++) { kwObj[types[i]] = atom;};\n\n  // each operator will add a property to kwObj with value of {type: \"operator\", style: \"keyword\"}\n  var operators = ['eq', 'ne', 'lt', 'le', 'gt', 'ge', ':=', '=', '>', '>=', '<', '<=', '.', '|', '?', 'and', 'or', 'div', 'idiv', 'mod', '*', '/', '+', '-'];\n  for(var i=0, l=operators.length; i < l; i++) { kwObj[operators[i]] = operator;};\n\n  // each axis_specifiers will add a property to kwObj with value of {type: \"axis_specifier\", style: \"qualifier\"}\n  var axis_specifiers = [\"self::\", \"attribute::\", \"child::\", \"descendant::\", \"descendant-or-self::\", \"parent::\",\n                         \"ancestor::\", \"ancestor-or-self::\", \"following::\", \"preceding::\", \"following-sibling::\", \"preceding-sibling::\"];\n  for(var i=0, l=axis_specifiers.length; i < l; i++) { kwObj[axis_specifiers[i]] = qualifier; };\n\n  return kwObj;\n}();\n\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\n\n// the primary mode tokenizer\nfunction tokenBase(stream, state) {\n  var ch = stream.next(),\n      mightBeFunction = false,\n      isEQName = isEQNameAhead(stream);\n\n  // an XML tag (if not in some sub, chained tokenizer)\n  if (ch == \"<\") {\n    if(stream.match(\"!--\", true))\n      return chain(stream, state, tokenXMLComment);\n\n    if(stream.match(\"![CDATA\", false)) {\n      state.tokenize = tokenCDATA;\n      return \"tag\";\n    }\n\n    if(stream.match(\"?\", false)) {\n      return chain(stream, state, tokenPreProcessing);\n    }\n\n    var isclose = stream.eat(\"/\");\n    stream.eatSpace();\n    var tagName = \"\", c;\n    while ((c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/))) tagName += c;\n\n    return chain(stream, state, tokenTag(tagName, isclose));\n  }\n  // start code block\n  else if(ch == \"{\") {\n    pushStateStack(state, { type: \"codeblock\"});\n    return null;\n  }\n  // end code block\n  else if(ch == \"}\") {\n    popStateStack(state);\n    return null;\n  }\n  // if we're in an XML block\n  else if(isInXmlBlock(state)) {\n    if(ch == \">\")\n      return \"tag\";\n    else if(ch == \"/\" && stream.eat(\">\")) {\n      popStateStack(state);\n      return \"tag\";\n    }\n    else\n      return \"variable\";\n  }\n  // if a number\n  else if (/\\d/.test(ch)) {\n    stream.match(/^\\d*(?:\\.\\d*)?(?:E[+\\-]?\\d+)?/);\n    return \"atom\";\n  }\n  // comment start\n  else if (ch === \"(\" && stream.eat(\":\")) {\n    pushStateStack(state, { type: \"comment\"});\n    return chain(stream, state, tokenComment);\n  }\n  // quoted string\n  else if (!isEQName && (ch === '\"' || ch === \"'\"))\n    return startString(stream, state, ch);\n  // variable\n  else if(ch === \"$\") {\n    return chain(stream, state, tokenVariable);\n  }\n  // assignment\n  else if(ch ===\":\" && stream.eat(\"=\")) {\n    return \"keyword\";\n  }\n  // open paren\n  else if(ch === \"(\") {\n    pushStateStack(state, { type: \"paren\"});\n    return null;\n  }\n  // close paren\n  else if(ch === \")\") {\n    popStateStack(state);\n    return null;\n  }\n  // open paren\n  else if(ch === \"[\") {\n    pushStateStack(state, { type: \"bracket\"});\n    return null;\n  }\n  // close paren\n  else if(ch === \"]\") {\n    popStateStack(state);\n    return null;\n  }\n  else {\n    var known = keywords.propertyIsEnumerable(ch) && keywords[ch];\n\n    // if there's a EQName ahead, consume the rest of the string portion, it's likely a function\n    if(isEQName && ch === '\\\"') while(stream.next() !== '\"'){}\n    if(isEQName && ch === '\\'') while(stream.next() !== '\\''){}\n\n    // gobble up a word if the character is not known\n    if(!known) stream.eatWhile(/[\\w\\$_-]/);\n\n    // gobble a colon in the case that is a lib func type call fn:doc\n    var foundColon = stream.eat(\":\");\n\n    // if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier\n    // which should get matched as a keyword\n    if(!stream.eat(\":\") && foundColon) {\n      stream.eatWhile(/[\\w\\$_-]/);\n    }\n    // if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)\n    if(stream.match(/^[ \\t]*\\(/, false)) {\n      mightBeFunction = true;\n    }\n    // is the word a keyword?\n    var word = stream.current();\n    known = keywords.propertyIsEnumerable(word) && keywords[word];\n\n    // if we think it's a function call but not yet known,\n    // set style to variable for now for lack of something better\n    if(mightBeFunction && !known) known = {type: \"function_call\", style: \"def\"};\n\n    // if the previous word was element, attribute, axis specifier, this word should be the name of that\n    if(isInXmlConstructor(state)) {\n      popStateStack(state);\n      return \"variable\";\n    }\n    // as previously checked, if the word is element,attribute, axis specifier, call it an \"xmlconstructor\" and\n    // push the stack so we know to look for it on the next word\n    if(word == \"element\" || word == \"attribute\" || known.type == \"axis_specifier\") pushStateStack(state, {type: \"xmlconstructor\"});\n\n    // if the word is known, return the details of that else just call this a generic 'word'\n    return known ? known.style : \"variable\";\n  }\n}\n\n// handle comments, including nested\nfunction tokenComment(stream, state) {\n  var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;\n  while (ch = stream.next()) {\n    if (ch == \")\" && maybeEnd) {\n      if(nestedCount > 0)\n        nestedCount--;\n      else {\n        popStateStack(state);\n        break;\n      }\n    }\n    else if(ch == \":\" && maybeNested) {\n      nestedCount++;\n    }\n    maybeEnd = (ch == \":\");\n    maybeNested = (ch == \"(\");\n  }\n\n  return \"comment\";\n}\n\n// tokenizer for string literals\n// optionally pass a tokenizer function to set state.tokenize back to when finished\nfunction tokenString(quote, f) {\n  return function(stream, state) {\n    var ch;\n    while (ch = stream.next()) {\n      if (ch == quote) {\n        popStateStack(state);\n        if (f) state.tokenize = f;\n        break;\n      } else if (stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n        // if we're in a string and in an XML block, allow an embedded code block in an attribute\n        pushStateStack(state, { type: \"codeblock\"});\n        state.tokenize = tokenBase;\n        return \"string\";\n      }\n    }\n\n    return \"string\";\n  };\n}\n\nfunction startString(stream, state, quote, f) {\n  let tokenize = tokenString(quote, f);\n  pushStateStack(state, { type: \"string\", name: quote, tokenize });\n  return chain(stream, state, tokenize);\n}\n\n// tokenizer for variables\nfunction tokenVariable(stream, state) {\n  var isVariableChar = /[\\w\\$_-]/;\n\n  // a variable may start with a quoted EQName so if the next character is quote, consume to the next quote\n  if(stream.eat(\"\\\"\")) {\n    while(stream.next() !== '\\\"'){};\n    stream.eat(\":\");\n  } else {\n    stream.eatWhile(isVariableChar);\n    if(!stream.match(\":=\", false)) stream.eat(\":\");\n  }\n  stream.eatWhile(isVariableChar);\n  state.tokenize = tokenBase;\n  return \"variable\";\n}\n\n// tokenizer for XML tags\nfunction tokenTag(name, isclose) {\n  return function(stream, state) {\n    stream.eatSpace();\n    if(isclose && stream.eat(\">\")) {\n      popStateStack(state);\n      state.tokenize = tokenBase;\n      return \"tag\";\n    }\n    // self closing tag without attributes?\n    if(!stream.eat(\"/\"))\n      pushStateStack(state, { type: \"tag\", name: name, tokenize: tokenBase});\n    if(!stream.eat(\">\")) {\n      state.tokenize = tokenAttribute;\n      return \"tag\";\n    }\n    else {\n      state.tokenize = tokenBase;\n    }\n    return \"tag\";\n  };\n}\n\n// tokenizer for XML attributes\nfunction tokenAttribute(stream, state) {\n  var ch = stream.next();\n\n  if(ch == \"/\" && stream.eat(\">\")) {\n    if(isInXmlAttributeBlock(state)) popStateStack(state);\n    if(isInXmlBlock(state)) popStateStack(state);\n    return \"tag\";\n  }\n  if(ch == \">\") {\n    if(isInXmlAttributeBlock(state)) popStateStack(state);\n    return \"tag\";\n  }\n  if(ch == \"=\")\n    return null;\n  // quoted string\n  if (ch == '\"' || ch == \"'\")\n    return startString(stream, state, ch, tokenAttribute);\n\n  if(!isInXmlAttributeBlock(state))\n    pushStateStack(state, { type: \"attribute\", tokenize: tokenAttribute});\n\n  stream.eat(/[a-zA-Z_:]/);\n  stream.eatWhile(/[-a-zA-Z0-9_:.]/);\n  stream.eatSpace();\n\n  // the case where the attribute has not value and the tag was closed\n  if(stream.match(\">\", false) || stream.match(\"/\", false)) {\n    popStateStack(state);\n    state.tokenize = tokenBase;\n  }\n\n  return \"attribute\";\n}\n\n// handle comments, including nested\nfunction tokenXMLComment(stream, state) {\n  var ch;\n  while (ch = stream.next()) {\n    if (ch == \"-\" && stream.match(\"->\", true)) {\n      state.tokenize = tokenBase;\n      return \"comment\";\n    }\n  }\n}\n\n\n// handle CDATA\nfunction tokenCDATA(stream, state) {\n  var ch;\n  while (ch = stream.next()) {\n    if (ch == \"]\" && stream.match(\"]\", true)) {\n      state.tokenize = tokenBase;\n      return \"comment\";\n    }\n  }\n}\n\n// handle preprocessing instructions\nfunction tokenPreProcessing(stream, state) {\n  var ch;\n  while (ch = stream.next()) {\n    if (ch == \"?\" && stream.match(\">\", true)) {\n      state.tokenize = tokenBase;\n      return \"processingInstruction\";\n    }\n  }\n}\n\n\n// functions to test the current context of the state\nfunction isInXmlBlock(state) { return isIn(state, \"tag\"); }\nfunction isInXmlAttributeBlock(state) { return isIn(state, \"attribute\"); }\nfunction isInXmlConstructor(state) { return isIn(state, \"xmlconstructor\"); }\nfunction isInString(state) { return isIn(state, \"string\"); }\n\nfunction isEQNameAhead(stream) {\n  // assume we've already eaten a quote (\")\n  if(stream.current() === '\"')\n    return stream.match(/^[^\\\"]+\\\"\\:/, false);\n  else if(stream.current() === '\\'')\n    return stream.match(/^[^\\\"]+\\'\\:/, false);\n  else\n    return false;\n}\n\nfunction isIn(state, type) {\n  return (state.stack.length && state.stack[state.stack.length - 1].type == type);\n}\n\nfunction pushStateStack(state, newState) {\n  state.stack.push(newState);\n}\n\nfunction popStateStack(state) {\n  state.stack.pop();\n  var reinstateTokenize = state.stack.length && state.stack[state.stack.length-1].tokenize;\n  state.tokenize = reinstateTokenize || tokenBase;\n}\n\n// the interface for the mode API\nconst xQuery = {\n  name: \"xquery\",\n  startState: function() {\n    return {\n      tokenize: tokenBase,\n      cc: [],\n      stack: []\n    };\n  },\n\n  token: function(stream, state) {\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    return style;\n  },\n\n  languageData: {\n    commentTokens: {block: {open: \"(:\", close: \":)\"}}\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS94cXVlcnkuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0EsWUFBWTtBQUNaLG1CQUFtQjtBQUNuQixpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxrQ0FBa0Msa0JBQWtCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTyxPQUFPOztBQUU3QztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPLE9BQU87O0FBRTdDLCtEQUErRDtBQUMvRDtBQUNBLG1DQUFtQyxPQUFPLE9BQU87O0FBRWpELHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0EseUNBQXlDLE9BQU8sT0FBTzs7QUFFdkQ7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLHVCQUF1Qjs7QUFFakk7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdCQUF3QjtBQUNoQztBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsdUNBQXVDO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkNBQTZDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLDRDQUE0Qzs7QUFFeEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsK0JBQStCO0FBQy9CLHdDQUF3QztBQUN4QyxxQ0FBcUM7QUFDckMsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2tyenlzenRvZmtvY290L0Rlc2t0b3AvbGFuZGluZy1wYWdlL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS94cXVlcnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhlIGtleXdvcmRzIG9iamVjdCBpcyBzZXQgdG8gdGhlIHJlc3VsdCBvZiB0aGlzIHNlbGYgZXhlY3V0aW5nXG4vLyBmdW5jdGlvbi4gRWFjaCBrZXl3b3JkIGlzIGEgcHJvcGVydHkgb2YgdGhlIGtleXdvcmRzIG9iamVjdCB3aG9zZVxuLy8gdmFsdWUgaXMge3R5cGU6IGF0eXBlLCBzdHlsZTogYXN0eWxlfVxudmFyIGtleXdvcmRzID0gZnVuY3Rpb24oKXtcbiAgLy8gY29udmVuaWVuY2UgZnVuY3Rpb25zIHVzZWQgdG8gYnVpbGQga2V5d29yZHMgb2JqZWN0XG4gIGZ1bmN0aW9uIGt3KHR5cGUpIHtyZXR1cm4ge3R5cGU6IHR5cGUsIHN0eWxlOiBcImtleXdvcmRcIn07fVxuICB2YXIgb3BlcmF0b3IgPSBrdyhcIm9wZXJhdG9yXCIpXG4gICwgYXRvbSA9IHt0eXBlOiBcImF0b21cIiwgc3R5bGU6IFwiYXRvbVwifVxuICAsIHB1bmN0dWF0aW9uID0ge3R5cGU6IFwicHVuY3R1YXRpb25cIiwgc3R5bGU6IG51bGx9XG4gICwgcXVhbGlmaWVyID0ge3R5cGU6IFwiYXhpc19zcGVjaWZpZXJcIiwgc3R5bGU6IFwicXVhbGlmaWVyXCJ9O1xuXG4gIC8vIGt3T2JqIGlzIHdoYXQgaXMgcmV0dXJuIGZyb20gdGhpcyBmdW5jdGlvbiBhdCB0aGUgZW5kXG4gIHZhciBrd09iaiA9IHtcbiAgICAnLCc6IHB1bmN0dWF0aW9uXG4gIH07XG5cbiAgLy8gYSBsaXN0IG9mICdiYXNpYycga2V5d29yZHMuIEZvciBlYWNoIGFkZCBhIHByb3BlcnR5IHRvIGt3T2JqIHdpdGggdGhlIHZhbHVlIG9mXG4gIC8vIHt0eXBlOiBiYXNpY1tpXSwgc3R5bGU6IFwia2V5d29yZFwifSBlLmcuICdhZnRlcicgLS0+IHt0eXBlOiBcImFmdGVyXCIsIHN0eWxlOiBcImtleXdvcmRcIn1cbiAgdmFyIGJhc2ljID0gWydhZnRlcicsICdhbGwnLCAnYWxsb3dpbmcnLCAnYW5jZXN0b3InLCAnYW5jZXN0b3Itb3Itc2VsZicsICdhbnknLCAnYXJyYXknLCAnYXMnLFxuICAgICAgICAgICAgICAgJ2FzY2VuZGluZycsICdhdCcsICdhdHRyaWJ1dGUnLCAnYmFzZS11cmknLCAnYmVmb3JlJywgJ2JvdW5kYXJ5LXNwYWNlJywgJ2J5JywgJ2Nhc2UnLCAnY2FzdCcsXG4gICAgICAgICAgICAgICAnY2FzdGFibGUnLCAnY2F0Y2gnLCAnY2hpbGQnLCAnY29sbGF0aW9uJywgJ2NvbW1lbnQnLCAnY29uc3RydWN0aW9uJywgJ2NvbnRhaW5zJywgJ2NvbnRlbnQnLFxuICAgICAgICAgICAgICAgJ2NvbnRleHQnLCAnY29weScsICdjb3B5LW5hbWVzcGFjZXMnLCAnY291bnQnLCAnZGVjaW1hbC1mb3JtYXQnLCAnZGVjbGFyZScsICdkZWZhdWx0JywgJ2RlbGV0ZScsXG4gICAgICAgICAgICAgICAnZGVzY2VuZGFudCcsICdkZXNjZW5kYW50LW9yLXNlbGYnLCAnZGVzY2VuZGluZycsICdkaWFjcml0aWNzJywgJ2RpZmZlcmVudCcsICdkaXN0YW5jZScsXG4gICAgICAgICAgICAgICAnZG9jdW1lbnQnLCAnZG9jdW1lbnQtbm9kZScsICdlbGVtZW50JywgJ2Vsc2UnLCAnZW1wdHknLCAnZW1wdHktc2VxdWVuY2UnLCAnZW5jb2RpbmcnLCAnZW5kJyxcbiAgICAgICAgICAgICAgICdlbnRpcmUnLCAnZXZlcnknLCAnZXhhY3RseScsICdleGNlcHQnLCAnZXh0ZXJuYWwnLCAnZmlyc3QnLCAnZm9sbG93aW5nJywgJ2ZvbGxvd2luZy1zaWJsaW5nJyxcbiAgICAgICAgICAgICAgICdmb3InLCAnZnJvbScsICdmdGFuZCcsICdmdG5vdCcsICdmdC1vcHRpb24nLCAnZnRvcicsICdmdW5jdGlvbicsICdmdXp6eScsICdncmVhdGVzdCcsICdncm91cCcsXG4gICAgICAgICAgICAgICAnaWYnLCAnaW1wb3J0JywgJ2luJywgJ2luaGVyaXQnLCAnaW5zZW5zaXRpdmUnLCAnaW5zZXJ0JywgJ2luc3RhbmNlJywgJ2ludGVyc2VjdCcsICdpbnRvJyxcbiAgICAgICAgICAgICAgICdpbnZva2UnLCAnaXMnLCAnaXRlbScsICdsYW5ndWFnZScsICdsYXN0JywgJ2xheCcsICdsZWFzdCcsICdsZXQnLCAnbGV2ZWxzJywgJ2xvd2VyY2FzZScsICdtYXAnLFxuICAgICAgICAgICAgICAgJ21vZGlmeScsICdtb2R1bGUnLCAnbW9zdCcsICduYW1lc3BhY2UnLCAnbmV4dCcsICdubycsICdub2RlJywgJ25vZGVzJywgJ25vLWluaGVyaXQnLFxuICAgICAgICAgICAgICAgJ25vLXByZXNlcnZlJywgJ25vdCcsICdvY2N1cnMnLCAnb2YnLCAnb25seScsICdvcHRpb24nLCAnb3JkZXInLCAnb3JkZXJlZCcsICdvcmRlcmluZycsXG4gICAgICAgICAgICAgICAncGFyYWdyYXBoJywgJ3BhcmFncmFwaHMnLCAncGFyZW50JywgJ3BocmFzZScsICdwcmVjZWRpbmcnLCAncHJlY2VkaW5nLXNpYmxpbmcnLCAncHJlc2VydmUnLFxuICAgICAgICAgICAgICAgJ3ByZXZpb3VzJywgJ3Byb2Nlc3NpbmctaW5zdHJ1Y3Rpb24nLCAncmVsYXRpb25zaGlwJywgJ3JlbmFtZScsICdyZXBsYWNlJywgJ3JldHVybicsXG4gICAgICAgICAgICAgICAncmV2YWxpZGF0aW9uJywgJ3NhbWUnLCAnc2F0aXNmaWVzJywgJ3NjaGVtYScsICdzY2hlbWEtYXR0cmlidXRlJywgJ3NjaGVtYS1lbGVtZW50JywgJ3Njb3JlJyxcbiAgICAgICAgICAgICAgICdzZWxmJywgJ3NlbnNpdGl2ZScsICdzZW50ZW5jZScsICdzZW50ZW5jZXMnLCAnc2VxdWVuY2UnLCAnc2tpcCcsICdzbGlkaW5nJywgJ3NvbWUnLCAnc3RhYmxlJyxcbiAgICAgICAgICAgICAgICdzdGFydCcsICdzdGVtbWluZycsICdzdG9wJywgJ3N0cmljdCcsICdzdHJpcCcsICdzd2l0Y2gnLCAndGV4dCcsICd0aGVuJywgJ3RoZXNhdXJ1cycsICd0aW1lcycsXG4gICAgICAgICAgICAgICAndG8nLCAndHJhbnNmb3JtJywgJ3RyZWF0JywgJ3RyeScsICd0dW1ibGluZycsICd0eXBlJywgJ3R5cGVzd2l0Y2gnLCAndW5pb24nLCAndW5vcmRlcmVkJyxcbiAgICAgICAgICAgICAgICd1cGRhdGUnLCAndXBkYXRpbmcnLCAndXBwZXJjYXNlJywgJ3VzaW5nJywgJ3ZhbGlkYXRlJywgJ3ZhbHVlJywgJ3ZhcmlhYmxlJywgJ3ZlcnNpb24nLFxuICAgICAgICAgICAgICAgJ3dlaWdodCcsICd3aGVuJywgJ3doZXJlJywgJ3dpbGRjYXJkcycsICd3aW5kb3cnLCAnd2l0aCcsICd3aXRob3V0JywgJ3dvcmQnLCAnd29yZHMnLCAneHF1ZXJ5J107XG4gIGZvcih2YXIgaT0wLCBsPWJhc2ljLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBrd09ialtiYXNpY1tpXV0gPSBrdyhiYXNpY1tpXSk7fTtcblxuICAvLyBhIGxpc3Qgb2YgdHlwZXMuIEZvciBlYWNoIGFkZCBhIHByb3BlcnR5IHRvIGt3T2JqIHdpdGggdGhlIHZhbHVlIG9mXG4gIC8vIHt0eXBlOiBcImF0b21cIiwgc3R5bGU6IFwiYXRvbVwifVxuICB2YXIgdHlwZXMgPSBbJ3hzOmFueUF0b21pY1R5cGUnLCAneHM6YW55U2ltcGxlVHlwZScsICd4czphbnlUeXBlJywgJ3hzOmFueVVSSScsXG4gICAgICAgICAgICAgICAneHM6YmFzZTY0QmluYXJ5JywgJ3hzOmJvb2xlYW4nLCAneHM6Ynl0ZScsICd4czpkYXRlJywgJ3hzOmRhdGVUaW1lJywgJ3hzOmRhdGVUaW1lU3RhbXAnLFxuICAgICAgICAgICAgICAgJ3hzOmRheVRpbWVEdXJhdGlvbicsICd4czpkZWNpbWFsJywgJ3hzOmRvdWJsZScsICd4czpkdXJhdGlvbicsICd4czpFTlRJVElFUycsICd4czpFTlRJVFknLFxuICAgICAgICAgICAgICAgJ3hzOmZsb2F0JywgJ3hzOmdEYXknLCAneHM6Z01vbnRoJywgJ3hzOmdNb250aERheScsICd4czpnWWVhcicsICd4czpnWWVhck1vbnRoJywgJ3hzOmhleEJpbmFyeScsXG4gICAgICAgICAgICAgICAneHM6SUQnLCAneHM6SURSRUYnLCAneHM6SURSRUZTJywgJ3hzOmludCcsICd4czppbnRlZ2VyJywgJ3hzOml0ZW0nLCAneHM6amF2YScsICd4czpsYW5ndWFnZScsXG4gICAgICAgICAgICAgICAneHM6bG9uZycsICd4czpOYW1lJywgJ3hzOk5DTmFtZScsICd4czpuZWdhdGl2ZUludGVnZXInLCAneHM6Tk1UT0tFTicsICd4czpOTVRPS0VOUycsXG4gICAgICAgICAgICAgICAneHM6bm9uTmVnYXRpdmVJbnRlZ2VyJywgJ3hzOm5vblBvc2l0aXZlSW50ZWdlcicsICd4czpub3JtYWxpemVkU3RyaW5nJywgJ3hzOk5PVEFUSU9OJyxcbiAgICAgICAgICAgICAgICd4czpudW1lcmljJywgJ3hzOnBvc2l0aXZlSW50ZWdlcicsICd4czpwcmVjaXNpb25EZWNpbWFsJywgJ3hzOlFOYW1lJywgJ3hzOnNob3J0JywgJ3hzOnN0cmluZycsXG4gICAgICAgICAgICAgICAneHM6dGltZScsICd4czp0b2tlbicsICd4czp1bnNpZ25lZEJ5dGUnLCAneHM6dW5zaWduZWRJbnQnLCAneHM6dW5zaWduZWRMb25nJyxcbiAgICAgICAgICAgICAgICd4czp1bnNpZ25lZFNob3J0JywgJ3hzOnVudHlwZWQnLCAneHM6dW50eXBlZEF0b21pYycsICd4czp5ZWFyTW9udGhEdXJhdGlvbiddO1xuICBmb3IodmFyIGk9MCwgbD10eXBlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsga3dPYmpbdHlwZXNbaV1dID0gYXRvbTt9O1xuXG4gIC8vIGVhY2ggb3BlcmF0b3Igd2lsbCBhZGQgYSBwcm9wZXJ0eSB0byBrd09iaiB3aXRoIHZhbHVlIG9mIHt0eXBlOiBcIm9wZXJhdG9yXCIsIHN0eWxlOiBcImtleXdvcmRcIn1cbiAgdmFyIG9wZXJhdG9ycyA9IFsnZXEnLCAnbmUnLCAnbHQnLCAnbGUnLCAnZ3QnLCAnZ2UnLCAnOj0nLCAnPScsICc+JywgJz49JywgJzwnLCAnPD0nLCAnLicsICd8JywgJz8nLCAnYW5kJywgJ29yJywgJ2RpdicsICdpZGl2JywgJ21vZCcsICcqJywgJy8nLCAnKycsICctJ107XG4gIGZvcih2YXIgaT0wLCBsPW9wZXJhdG9ycy5sZW5ndGg7IGkgPCBsOyBpKyspIHsga3dPYmpbb3BlcmF0b3JzW2ldXSA9IG9wZXJhdG9yO307XG5cbiAgLy8gZWFjaCBheGlzX3NwZWNpZmllcnMgd2lsbCBhZGQgYSBwcm9wZXJ0eSB0byBrd09iaiB3aXRoIHZhbHVlIG9mIHt0eXBlOiBcImF4aXNfc3BlY2lmaWVyXCIsIHN0eWxlOiBcInF1YWxpZmllclwifVxuICB2YXIgYXhpc19zcGVjaWZpZXJzID0gW1wic2VsZjo6XCIsIFwiYXR0cmlidXRlOjpcIiwgXCJjaGlsZDo6XCIsIFwiZGVzY2VuZGFudDo6XCIsIFwiZGVzY2VuZGFudC1vci1zZWxmOjpcIiwgXCJwYXJlbnQ6OlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgIFwiYW5jZXN0b3I6OlwiLCBcImFuY2VzdG9yLW9yLXNlbGY6OlwiLCBcImZvbGxvd2luZzo6XCIsIFwicHJlY2VkaW5nOjpcIiwgXCJmb2xsb3dpbmctc2libGluZzo6XCIsIFwicHJlY2VkaW5nLXNpYmxpbmc6OlwiXTtcbiAgZm9yKHZhciBpPTAsIGw9YXhpc19zcGVjaWZpZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBrd09ialtheGlzX3NwZWNpZmllcnNbaV1dID0gcXVhbGlmaWVyOyB9O1xuXG4gIHJldHVybiBrd09iajtcbn0oKTtcblxuZnVuY3Rpb24gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgZikge1xuICBzdGF0ZS50b2tlbml6ZSA9IGY7XG4gIHJldHVybiBmKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyB0aGUgcHJpbWFyeSBtb2RlIHRva2VuaXplclxuZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RyZWFtLm5leHQoKSxcbiAgICAgIG1pZ2h0QmVGdW5jdGlvbiA9IGZhbHNlLFxuICAgICAgaXNFUU5hbWUgPSBpc0VRTmFtZUFoZWFkKHN0cmVhbSk7XG5cbiAgLy8gYW4gWE1MIHRhZyAoaWYgbm90IGluIHNvbWUgc3ViLCBjaGFpbmVkIHRva2VuaXplcilcbiAgaWYgKGNoID09IFwiPFwiKSB7XG4gICAgaWYoc3RyZWFtLm1hdGNoKFwiIS0tXCIsIHRydWUpKVxuICAgICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuWE1MQ29tbWVudCk7XG5cbiAgICBpZihzdHJlYW0ubWF0Y2goXCIhW0NEQVRBXCIsIGZhbHNlKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNEQVRBO1xuICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgfVxuXG4gICAgaWYoc3RyZWFtLm1hdGNoKFwiP1wiLCBmYWxzZSkpIHtcbiAgICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlblByZVByb2Nlc3NpbmcpO1xuICAgIH1cblxuICAgIHZhciBpc2Nsb3NlID0gc3RyZWFtLmVhdChcIi9cIik7XG4gICAgc3RyZWFtLmVhdFNwYWNlKCk7XG4gICAgdmFyIHRhZ05hbWUgPSBcIlwiLCBjO1xuICAgIHdoaWxlICgoYyA9IHN0cmVhbS5lYXQoL1teXFxzXFx1MDBhMD08PlxcXCJcXCdcXC8/XS8pKSkgdGFnTmFtZSArPSBjO1xuXG4gICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuVGFnKHRhZ05hbWUsIGlzY2xvc2UpKTtcbiAgfVxuICAvLyBzdGFydCBjb2RlIGJsb2NrXG4gIGVsc2UgaWYoY2ggPT0gXCJ7XCIpIHtcbiAgICBwdXNoU3RhdGVTdGFjayhzdGF0ZSwgeyB0eXBlOiBcImNvZGVibG9ja1wifSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gZW5kIGNvZGUgYmxvY2tcbiAgZWxzZSBpZihjaCA9PSBcIn1cIikge1xuICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIGlmIHdlJ3JlIGluIGFuIFhNTCBibG9ja1xuICBlbHNlIGlmKGlzSW5YbWxCbG9jayhzdGF0ZSkpIHtcbiAgICBpZihjaCA9PSBcIj5cIilcbiAgICAgIHJldHVybiBcInRhZ1wiO1xuICAgIGVsc2UgaWYoY2ggPT0gXCIvXCIgJiYgc3RyZWFtLmVhdChcIj5cIikpIHtcbiAgICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gIH1cbiAgLy8gaWYgYSBudW1iZXJcbiAgZWxzZSBpZiAoL1xcZC8udGVzdChjaCkpIHtcbiAgICBzdHJlYW0ubWF0Y2goL15cXGQqKD86XFwuXFxkKik/KD86RVsrXFwtXT9cXGQrKT8vKTtcbiAgICByZXR1cm4gXCJhdG9tXCI7XG4gIH1cbiAgLy8gY29tbWVudCBzdGFydFxuICBlbHNlIGlmIChjaCA9PT0gXCIoXCIgJiYgc3RyZWFtLmVhdChcIjpcIikpIHtcbiAgICBwdXNoU3RhdGVTdGFjayhzdGF0ZSwgeyB0eXBlOiBcImNvbW1lbnRcIn0pO1xuICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlbkNvbW1lbnQpO1xuICB9XG4gIC8vIHF1b3RlZCBzdHJpbmdcbiAgZWxzZSBpZiAoIWlzRVFOYW1lICYmIChjaCA9PT0gJ1wiJyB8fCBjaCA9PT0gXCInXCIpKVxuICAgIHJldHVybiBzdGFydFN0cmluZyhzdHJlYW0sIHN0YXRlLCBjaCk7XG4gIC8vIHZhcmlhYmxlXG4gIGVsc2UgaWYoY2ggPT09IFwiJFwiKSB7XG4gICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuVmFyaWFibGUpO1xuICB9XG4gIC8vIGFzc2lnbm1lbnRcbiAgZWxzZSBpZihjaCA9PT1cIjpcIiAmJiBzdHJlYW0uZWF0KFwiPVwiKSkge1xuICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgfVxuICAvLyBvcGVuIHBhcmVuXG4gIGVsc2UgaWYoY2ggPT09IFwiKFwiKSB7XG4gICAgcHVzaFN0YXRlU3RhY2soc3RhdGUsIHsgdHlwZTogXCJwYXJlblwifSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gY2xvc2UgcGFyZW5cbiAgZWxzZSBpZihjaCA9PT0gXCIpXCIpIHtcbiAgICBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBvcGVuIHBhcmVuXG4gIGVsc2UgaWYoY2ggPT09IFwiW1wiKSB7XG4gICAgcHVzaFN0YXRlU3RhY2soc3RhdGUsIHsgdHlwZTogXCJicmFja2V0XCJ9KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBjbG9zZSBwYXJlblxuICBlbHNlIGlmKGNoID09PSBcIl1cIikge1xuICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBrbm93biA9IGtleXdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKGNoKSAmJiBrZXl3b3Jkc1tjaF07XG5cbiAgICAvLyBpZiB0aGVyZSdzIGEgRVFOYW1lIGFoZWFkLCBjb25zdW1lIHRoZSByZXN0IG9mIHRoZSBzdHJpbmcgcG9ydGlvbiwgaXQncyBsaWtlbHkgYSBmdW5jdGlvblxuICAgIGlmKGlzRVFOYW1lICYmIGNoID09PSAnXFxcIicpIHdoaWxlKHN0cmVhbS5uZXh0KCkgIT09ICdcIicpe31cbiAgICBpZihpc0VRTmFtZSAmJiBjaCA9PT0gJ1xcJycpIHdoaWxlKHN0cmVhbS5uZXh0KCkgIT09ICdcXCcnKXt9XG5cbiAgICAvLyBnb2JibGUgdXAgYSB3b3JkIGlmIHRoZSBjaGFyYWN0ZXIgaXMgbm90IGtub3duXG4gICAgaWYoIWtub3duKSBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfLV0vKTtcblxuICAgIC8vIGdvYmJsZSBhIGNvbG9uIGluIHRoZSBjYXNlIHRoYXQgaXMgYSBsaWIgZnVuYyB0eXBlIGNhbGwgZm46ZG9jXG4gICAgdmFyIGZvdW5kQ29sb24gPSBzdHJlYW0uZWF0KFwiOlwiKTtcblxuICAgIC8vIGlmIHRoZXJlJ3Mgbm90IGEgc2Vjb25kIGNvbG9uLCBnb2JibGUgYW5vdGhlciB3b3JkLiBPdGhlcndpc2UsIGl0J3MgcHJvYmFibHkgYW4gYXhpcyBzcGVjaWZpZXJcbiAgICAvLyB3aGljaCBzaG91bGQgZ2V0IG1hdGNoZWQgYXMgYSBrZXl3b3JkXG4gICAgaWYoIXN0cmVhbS5lYXQoXCI6XCIpICYmIGZvdW5kQ29sb24pIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF8tXS8pO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgbmV4dCBub24gd2hpdGVzcGFjZSBjaGFyYWN0ZXIgaXMgYW4gb3BlbiBwYXJlbiwgdGhpcyBpcyBwcm9iYWJseSBhIGZ1bmN0aW9uIChpZiBub3QgYSBrZXl3b3JkIG9mIG90aGVyIHNvcnQpXG4gICAgaWYoc3RyZWFtLm1hdGNoKC9eWyBcXHRdKlxcKC8sIGZhbHNlKSkge1xuICAgICAgbWlnaHRCZUZ1bmN0aW9uID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gaXMgdGhlIHdvcmQgYSBrZXl3b3JkP1xuICAgIHZhciB3b3JkID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICBrbm93biA9IGtleXdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKHdvcmQpICYmIGtleXdvcmRzW3dvcmRdO1xuXG4gICAgLy8gaWYgd2UgdGhpbmsgaXQncyBhIGZ1bmN0aW9uIGNhbGwgYnV0IG5vdCB5ZXQga25vd24sXG4gICAgLy8gc2V0IHN0eWxlIHRvIHZhcmlhYmxlIGZvciBub3cgZm9yIGxhY2sgb2Ygc29tZXRoaW5nIGJldHRlclxuICAgIGlmKG1pZ2h0QmVGdW5jdGlvbiAmJiAha25vd24pIGtub3duID0ge3R5cGU6IFwiZnVuY3Rpb25fY2FsbFwiLCBzdHlsZTogXCJkZWZcIn07XG5cbiAgICAvLyBpZiB0aGUgcHJldmlvdXMgd29yZCB3YXMgZWxlbWVudCwgYXR0cmlidXRlLCBheGlzIHNwZWNpZmllciwgdGhpcyB3b3JkIHNob3VsZCBiZSB0aGUgbmFtZSBvZiB0aGF0XG4gICAgaWYoaXNJblhtbENvbnN0cnVjdG9yKHN0YXRlKSkge1xuICAgICAgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICAgIH1cbiAgICAvLyBhcyBwcmV2aW91c2x5IGNoZWNrZWQsIGlmIHRoZSB3b3JkIGlzIGVsZW1lbnQsYXR0cmlidXRlLCBheGlzIHNwZWNpZmllciwgY2FsbCBpdCBhbiBcInhtbGNvbnN0cnVjdG9yXCIgYW5kXG4gICAgLy8gcHVzaCB0aGUgc3RhY2sgc28gd2Uga25vdyB0byBsb29rIGZvciBpdCBvbiB0aGUgbmV4dCB3b3JkXG4gICAgaWYod29yZCA9PSBcImVsZW1lbnRcIiB8fCB3b3JkID09IFwiYXR0cmlidXRlXCIgfHwga25vd24udHlwZSA9PSBcImF4aXNfc3BlY2lmaWVyXCIpIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCB7dHlwZTogXCJ4bWxjb25zdHJ1Y3RvclwifSk7XG5cbiAgICAvLyBpZiB0aGUgd29yZCBpcyBrbm93biwgcmV0dXJuIHRoZSBkZXRhaWxzIG9mIHRoYXQgZWxzZSBqdXN0IGNhbGwgdGhpcyBhIGdlbmVyaWMgJ3dvcmQnXG4gICAgcmV0dXJuIGtub3duID8ga25vd24uc3R5bGUgOiBcInZhcmlhYmxlXCI7XG4gIH1cbn1cblxuLy8gaGFuZGxlIGNvbW1lbnRzLCBpbmNsdWRpbmcgbmVzdGVkXG5mdW5jdGlvbiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbWF5YmVFbmQgPSBmYWxzZSwgbWF5YmVOZXN0ZWQgPSBmYWxzZSwgbmVzdGVkQ291bnQgPSAwLCBjaDtcbiAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgIGlmIChjaCA9PSBcIilcIiAmJiBtYXliZUVuZCkge1xuICAgICAgaWYobmVzdGVkQ291bnQgPiAwKVxuICAgICAgICBuZXN0ZWRDb3VudC0tO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZihjaCA9PSBcIjpcIiAmJiBtYXliZU5lc3RlZCkge1xuICAgICAgbmVzdGVkQ291bnQrKztcbiAgICB9XG4gICAgbWF5YmVFbmQgPSAoY2ggPT0gXCI6XCIpO1xuICAgIG1heWJlTmVzdGVkID0gKGNoID09IFwiKFwiKTtcbiAgfVxuXG4gIHJldHVybiBcImNvbW1lbnRcIjtcbn1cblxuLy8gdG9rZW5pemVyIGZvciBzdHJpbmcgbGl0ZXJhbHNcbi8vIG9wdGlvbmFsbHkgcGFzcyBhIHRva2VuaXplciBmdW5jdGlvbiB0byBzZXQgc3RhdGUudG9rZW5pemUgYmFjayB0byB3aGVuIGZpbmlzaGVkXG5mdW5jdGlvbiB0b2tlblN0cmluZyhxdW90ZSwgZikge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaDtcbiAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICBpZiAoY2ggPT0gcXVvdGUpIHtcbiAgICAgICAgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgICAgIGlmIChmKSBzdGF0ZS50b2tlbml6ZSA9IGY7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goXCJ7XCIsIGZhbHNlKSAmJiBpc0luWG1sQXR0cmlidXRlQmxvY2soc3RhdGUpKSB7XG4gICAgICAgIC8vIGlmIHdlJ3JlIGluIGEgc3RyaW5nIGFuZCBpbiBhbiBYTUwgYmxvY2ssIGFsbG93IGFuIGVtYmVkZGVkIGNvZGUgYmxvY2sgaW4gYW4gYXR0cmlidXRlXG4gICAgICAgIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCB7IHR5cGU6IFwiY29kZWJsb2NrXCJ9KTtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBcInN0cmluZ1wiO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdGFydFN0cmluZyhzdHJlYW0sIHN0YXRlLCBxdW90ZSwgZikge1xuICBsZXQgdG9rZW5pemUgPSB0b2tlblN0cmluZyhxdW90ZSwgZik7XG4gIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCB7IHR5cGU6IFwic3RyaW5nXCIsIG5hbWU6IHF1b3RlLCB0b2tlbml6ZSB9KTtcbiAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuaXplKTtcbn1cblxuLy8gdG9rZW5pemVyIGZvciB2YXJpYWJsZXNcbmZ1bmN0aW9uIHRva2VuVmFyaWFibGUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgaXNWYXJpYWJsZUNoYXIgPSAvW1xcd1xcJF8tXS87XG5cbiAgLy8gYSB2YXJpYWJsZSBtYXkgc3RhcnQgd2l0aCBhIHF1b3RlZCBFUU5hbWUgc28gaWYgdGhlIG5leHQgY2hhcmFjdGVyIGlzIHF1b3RlLCBjb25zdW1lIHRvIHRoZSBuZXh0IHF1b3RlXG4gIGlmKHN0cmVhbS5lYXQoXCJcXFwiXCIpKSB7XG4gICAgd2hpbGUoc3RyZWFtLm5leHQoKSAhPT0gJ1xcXCInKXt9O1xuICAgIHN0cmVhbS5lYXQoXCI6XCIpO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5lYXRXaGlsZShpc1ZhcmlhYmxlQ2hhcik7XG4gICAgaWYoIXN0cmVhbS5tYXRjaChcIjo9XCIsIGZhbHNlKSkgc3RyZWFtLmVhdChcIjpcIik7XG4gIH1cbiAgc3RyZWFtLmVhdFdoaWxlKGlzVmFyaWFibGVDaGFyKTtcbiAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gIHJldHVybiBcInZhcmlhYmxlXCI7XG59XG5cbi8vIHRva2VuaXplciBmb3IgWE1MIHRhZ3NcbmZ1bmN0aW9uIHRva2VuVGFnKG5hbWUsIGlzY2xvc2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBzdHJlYW0uZWF0U3BhY2UoKTtcbiAgICBpZihpc2Nsb3NlICYmIHN0cmVhbS5lYXQoXCI+XCIpKSB7XG4gICAgICBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgfVxuICAgIC8vIHNlbGYgY2xvc2luZyB0YWcgd2l0aG91dCBhdHRyaWJ1dGVzP1xuICAgIGlmKCFzdHJlYW0uZWF0KFwiL1wiKSlcbiAgICAgIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCB7IHR5cGU6IFwidGFnXCIsIG5hbWU6IG5hbWUsIHRva2VuaXplOiB0b2tlbkJhc2V9KTtcbiAgICBpZighc3RyZWFtLmVhdChcIj5cIikpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5BdHRyaWJ1dGU7XG4gICAgICByZXR1cm4gXCJ0YWdcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICB9XG4gICAgcmV0dXJuIFwidGFnXCI7XG4gIH07XG59XG5cbi8vIHRva2VuaXplciBmb3IgWE1MIGF0dHJpYnV0ZXNcbmZ1bmN0aW9uIHRva2VuQXR0cmlidXRlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcblxuICBpZihjaCA9PSBcIi9cIiAmJiBzdHJlYW0uZWF0KFwiPlwiKSkge1xuICAgIGlmKGlzSW5YbWxBdHRyaWJ1dGVCbG9jayhzdGF0ZSkpIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgIGlmKGlzSW5YbWxCbG9jayhzdGF0ZSkpIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgIHJldHVybiBcInRhZ1wiO1xuICB9XG4gIGlmKGNoID09IFwiPlwiKSB7XG4gICAgaWYoaXNJblhtbEF0dHJpYnV0ZUJsb2NrKHN0YXRlKSkgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgcmV0dXJuIFwidGFnXCI7XG4gIH1cbiAgaWYoY2ggPT0gXCI9XCIpXG4gICAgcmV0dXJuIG51bGw7XG4gIC8vIHF1b3RlZCBzdHJpbmdcbiAgaWYgKGNoID09ICdcIicgfHwgY2ggPT0gXCInXCIpXG4gICAgcmV0dXJuIHN0YXJ0U3RyaW5nKHN0cmVhbSwgc3RhdGUsIGNoLCB0b2tlbkF0dHJpYnV0ZSk7XG5cbiAgaWYoIWlzSW5YbWxBdHRyaWJ1dGVCbG9jayhzdGF0ZSkpXG4gICAgcHVzaFN0YXRlU3RhY2soc3RhdGUsIHsgdHlwZTogXCJhdHRyaWJ1dGVcIiwgdG9rZW5pemU6IHRva2VuQXR0cmlidXRlfSk7XG5cbiAgc3RyZWFtLmVhdCgvW2EtekEtWl86XS8pO1xuICBzdHJlYW0uZWF0V2hpbGUoL1stYS16QS1aMC05XzouXS8pO1xuICBzdHJlYW0uZWF0U3BhY2UoKTtcblxuICAvLyB0aGUgY2FzZSB3aGVyZSB0aGUgYXR0cmlidXRlIGhhcyBub3QgdmFsdWUgYW5kIHRoZSB0YWcgd2FzIGNsb3NlZFxuICBpZihzdHJlYW0ubWF0Y2goXCI+XCIsIGZhbHNlKSB8fCBzdHJlYW0ubWF0Y2goXCIvXCIsIGZhbHNlKSkge1xuICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICB9XG5cbiAgcmV0dXJuIFwiYXR0cmlidXRlXCI7XG59XG5cbi8vIGhhbmRsZSBjb21tZW50cywgaW5jbHVkaW5nIG5lc3RlZFxuZnVuY3Rpb24gdG9rZW5YTUxDb21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGNoO1xuICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgaWYgKGNoID09IFwiLVwiICYmIHN0cmVhbS5tYXRjaChcIi0+XCIsIHRydWUpKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICB9XG4gIH1cbn1cblxuXG4vLyBoYW5kbGUgQ0RBVEFcbmZ1bmN0aW9uIHRva2VuQ0RBVEEoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgY2g7XG4gIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICBpZiAoY2ggPT0gXCJdXCIgJiYgc3RyZWFtLm1hdGNoKFwiXVwiLCB0cnVlKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgfVxuICB9XG59XG5cbi8vIGhhbmRsZSBwcmVwcm9jZXNzaW5nIGluc3RydWN0aW9uc1xuZnVuY3Rpb24gdG9rZW5QcmVQcm9jZXNzaW5nKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGNoO1xuICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgaWYgKGNoID09IFwiP1wiICYmIHN0cmVhbS5tYXRjaChcIj5cIiwgdHJ1ZSkpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgcmV0dXJuIFwicHJvY2Vzc2luZ0luc3RydWN0aW9uXCI7XG4gICAgfVxuICB9XG59XG5cblxuLy8gZnVuY3Rpb25zIHRvIHRlc3QgdGhlIGN1cnJlbnQgY29udGV4dCBvZiB0aGUgc3RhdGVcbmZ1bmN0aW9uIGlzSW5YbWxCbG9jayhzdGF0ZSkgeyByZXR1cm4gaXNJbihzdGF0ZSwgXCJ0YWdcIik7IH1cbmZ1bmN0aW9uIGlzSW5YbWxBdHRyaWJ1dGVCbG9jayhzdGF0ZSkgeyByZXR1cm4gaXNJbihzdGF0ZSwgXCJhdHRyaWJ1dGVcIik7IH1cbmZ1bmN0aW9uIGlzSW5YbWxDb25zdHJ1Y3RvcihzdGF0ZSkgeyByZXR1cm4gaXNJbihzdGF0ZSwgXCJ4bWxjb25zdHJ1Y3RvclwiKTsgfVxuZnVuY3Rpb24gaXNJblN0cmluZyhzdGF0ZSkgeyByZXR1cm4gaXNJbihzdGF0ZSwgXCJzdHJpbmdcIik7IH1cblxuZnVuY3Rpb24gaXNFUU5hbWVBaGVhZChzdHJlYW0pIHtcbiAgLy8gYXNzdW1lIHdlJ3ZlIGFscmVhZHkgZWF0ZW4gYSBxdW90ZSAoXCIpXG4gIGlmKHN0cmVhbS5jdXJyZW50KCkgPT09ICdcIicpXG4gICAgcmV0dXJuIHN0cmVhbS5tYXRjaCgvXlteXFxcIl0rXFxcIlxcOi8sIGZhbHNlKTtcbiAgZWxzZSBpZihzdHJlYW0uY3VycmVudCgpID09PSAnXFwnJylcbiAgICByZXR1cm4gc3RyZWFtLm1hdGNoKC9eW15cXFwiXStcXCdcXDovLCBmYWxzZSk7XG4gIGVsc2VcbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSW4oc3RhdGUsIHR5cGUpIHtcbiAgcmV0dXJuIChzdGF0ZS5zdGFjay5sZW5ndGggJiYgc3RhdGUuc3RhY2tbc3RhdGUuc3RhY2subGVuZ3RoIC0gMV0udHlwZSA9PSB0eXBlKTtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXRlU3RhY2soc3RhdGUsIG5ld1N0YXRlKSB7XG4gIHN0YXRlLnN0YWNrLnB1c2gobmV3U3RhdGUpO1xufVxuXG5mdW5jdGlvbiBwb3BTdGF0ZVN0YWNrKHN0YXRlKSB7XG4gIHN0YXRlLnN0YWNrLnBvcCgpO1xuICB2YXIgcmVpbnN0YXRlVG9rZW5pemUgPSBzdGF0ZS5zdGFjay5sZW5ndGggJiYgc3RhdGUuc3RhY2tbc3RhdGUuc3RhY2subGVuZ3RoLTFdLnRva2VuaXplO1xuICBzdGF0ZS50b2tlbml6ZSA9IHJlaW5zdGF0ZVRva2VuaXplIHx8IHRva2VuQmFzZTtcbn1cblxuLy8gdGhlIGludGVyZmFjZSBmb3IgdGhlIG1vZGUgQVBJXG5leHBvcnQgY29uc3QgeFF1ZXJ5ID0ge1xuICBuYW1lOiBcInhxdWVyeVwiLFxuICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5pemU6IHRva2VuQmFzZSxcbiAgICAgIGNjOiBbXSxcbiAgICAgIHN0YWNrOiBbXVxuICAgIH07XG4gIH0sXG5cbiAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcblxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBjb21tZW50VG9rZW5zOiB7YmxvY2s6IHtvcGVuOiBcIig6XCIsIGNsb3NlOiBcIjopXCJ9fVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@codemirror/legacy-modes/mode/xquery.js\n"));

/***/ })

}]);